// alembicPlugin
// Initial code generated by Softimage SDK Wizard
// Executed Fri Aug 19 09:14:49 UTC+0200 2011 by helge
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <xsi_application.h>
#include <xsi_context.h> 
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>
#include <xsi_argument.h>
#include <xsi_command.h>
#include <xsi_menu.h>
#include <xsi_uitoolkit.h> 
#include <xsi_progressbar.h>
#include <xsi_comapihandler.h>
#include <xsi_project.h>
#include <xsi_selection.h>
#include <xsi_model.h>
#include <xsi_null.h>
#include <xsi_camera.h>
#include <xsi_customoperator.h>
#include <xsi_expression.h>
#include <xsi_kinematics.h>
#include <xsi_kinematicstate.h>
#include <xsi_factory.h>
#include <xsi_primitive.h> 
#include <xsi_math.h>
#include <xsi_cluster.h>
#include <xsi_clusterproperty.h>
#include <xsi_primitive.h>
#include <xsi_geometry.h>
#include <xsi_polygonmesh.h>
#include <xsi_ppglayout.h>
#include <xsi_ppgitem.h>
#include <xsi_ppgeventcontext.h>
#include <xsi_icetree.h>
#include <xsi_icenode.h>
#include <xsi_icenodeinputport.h>
#include <xsi_icecompoundnode.h>
#include <xsi_utils.h>
#include <xsi_time.h>
#include <time.h>
#include <xsi_customoperator.h>
#include <xsi_operatorcontext.h>
#include <xsi_outputport.h>
#include "arnoldHelpers.h" 

using namespace XSI; 
using namespace MATH; 

#include <boost/exception/all.hpp>

#include "AlembicLicensing.h"

#include "AlembicWriteJob.h"
#include "AlembicPoints.h"
#include "AlembicCurves.h"
#include "CommonProfiler.h"
#include "CommonMeshUtilities.h"
#include "CommonUtilities.h"

SICALLBACK XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"Helge Mathee");
	in_reg.PutName(L"ExocortexAlembicSoftimage");
	in_reg.PutVersion(1,0);

	//if( HasAlembicWriterLicense() ) {
		in_reg.RegisterCommand(L"alembic_export",L"alembic_export");

		in_reg.RegisterMenu(siMenuMainFileExportID,L"alembic_MenuExport",false,false);

		in_reg.RegisterProperty(L"alembic_export_settings");
	//}

	//if( HasAlembicReaderLicense() ) {
		in_reg.RegisterCommand(L"alembic_import",L"alembic_import");
		in_reg.RegisterCommand(L"alembic_attach_metadata",L"alembic_attach_metadata");
		in_reg.RegisterCommand(L"alembic_create_item",L"alembic_create_item");
		in_reg.RegisterCommand(L"alembic_path_manager",L"alembic_path_manager");
		in_reg.RegisterCommand(L"alembic_profile_stats",L"alembic_profile_stats");

		in_reg.RegisterOperator(L"alembic_xform");
		in_reg.RegisterOperator(L"alembic_camera");
		in_reg.RegisterOperator(L"alembic_polymesh");
		in_reg.RegisterOperator(L"alembic_polymesh_topo");
		in_reg.RegisterOperator(L"alembic_nurbs");
		in_reg.RegisterOperator(L"alembic_bbox");
		in_reg.RegisterOperator(L"alembic_normals");
		in_reg.RegisterOperator(L"alembic_uvs");
		in_reg.RegisterOperator(L"alembic_crvlist");
		in_reg.RegisterOperator(L"alembic_crvlist_topo");
		in_reg.RegisterOperator(L"alembic_visibility");
		in_reg.RegisterOperator(L"alembic_geomapprox");
		in_reg.RegisterOperator(L"alembic_standinop");

		in_reg.RegisterMenu(siMenuMainFileImportID,L"alembic_MenuImport",false,false);
		in_reg.RegisterMenu(siMenuMainFileProjectID,L"alembic_MenuPathManager",false,false);
		in_reg.RegisterMenu(siMenuMainFileProjectID,L"alembic_ProfileStats",false,false);
		in_reg.RegisterMenu(siMenuTbGetPropertyID,L"alembic_MenuMetaData",false,false);

		in_reg.RegisterProperty(L"alembic_import_settings");
		in_reg.RegisterProperty(L"alembic_timecontrol");
		in_reg.RegisterProperty(L"alembic_metadata");

		// register ICE nodes
		Register_alembic_curves(in_reg);
		Register_alembic_points(in_reg);

		// register events
		in_reg.RegisterEvent(L"alembic_OnCloseScene",siOnCloseScene);
	//}

   ESS_LOG_INFO("PLUGIN loaded");

 	return CStatus::OK;
}

SICALLBACK XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
   deleteAllArchives();

	CString strPluginName;
	strPluginName = in_reg.GetName();
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

ESS_CALLBACK_START(alembic_export_Init,CRef&)

	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"exportjobs");
	return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_export_Execute,CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");

	//FORCE_CRASH_INVALID_ACCESS_VIOLATION; used for testing whether error reporting works.
	ESS_PROFILE_SCOPE("alembic_export_Execute");

   // get all of the jobs, and split them
   CString jobString = args[0].GetAsText();
   if(jobString.IsEmpty())
   {
	 CValue objectsAsValue = args[1];
   	CRefArray objects = objectsAsValue;
  
      if(objects.GetCount() == 0)
      {
         // use the selection
         objects = Application().GetSelection().GetArray();
         if(objects.GetCount() == 0)
         {
            Application().LogMessage(L"[ExocortexAlembic] No objects specified.",siErrorMsg);
            return CStatus::InvalidArgument;
         }
      }
      jobString += L"objects=";
      for(LONG i=0;i<objects.GetCount();i++)
      {
         if(i>0)
            jobString += L",";
         jobString += ProjectItem(objects[i]).GetFullName();
      }

      // let's setup the property
      CustomProperty settings = (CustomProperty) Application().GetActiveSceneRoot().AddProperty(L"alembic_export_settings");

      // inspect it
      CValueArray inspectArgs(5);
      CValue inspectResult;
      inspectArgs[0] = settings.GetFullName();
      inspectArgs[1] = L"";
      inspectArgs[2] = L"Export Settings";
      inspectArgs[3] = siModal;
      inspectArgs[4] = false;
      Application().ExecuteCommand(L"InspectObj",inspectArgs,inspectResult);
      
      // prepare for deletion
      inspectArgs.Resize(1);
      inspectArgs[0] = settings.GetFullName();
      if((bool)inspectResult)
      {
         Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
         return CStatus::Abort;
      }

      // retrieve the options
      jobString += L";in="+settings.GetParameterValue(L"frame_in").GetAsText();
      jobString += L";out="+settings.GetParameterValue(L"frame_out").GetAsText();
      jobString += L";step="+settings.GetParameterValue(L"frame_step").GetAsText();
      jobString += L";substep="+settings.GetParameterValue(L"frame_substep").GetAsText();
      LONG normalMode = settings.GetParameterValue(L"normals");
      bool transformCache = settings.GetParameterValue(L"transformcache");
      jobString += L";normals="+CValue(normalMode == 2l).GetAsText();
      if(transformCache)
      {
         jobString += L";transformcache=true";
         jobString += L";uvs=false";
         jobString += L";facesets=false";
         jobString += L";bindpose=false";
         jobString += L";dynamictopology=false";
      }
      else if(normalMode == 0)
      {
         jobString += L";purepointcache=true";
         jobString += L";uvs=false";
         jobString += L";facesets=false";
         jobString += L";bindpose=false";
         jobString += L";dynamictopology=false";
      }
      else
      {
         jobString += L";uvs="+settings.GetParameterValue(L"uvs").GetAsText();
         jobString += L";facesets="+settings.GetParameterValue(L"facesets").GetAsText();
	      jobString += L";bindpose="+settings.GetParameterValue(L"bindpose").GetAsText();
	      jobString += L";dynamictopology="+settings.GetParameterValue(L"dtopology").GetAsText();
      }
      jobString += L";guidecurves="+settings.GetParameterValue(L"guidecurves").GetAsText();
 
      
      LONG transformMode = settings.GetParameterValue(L"transforms");
      if( transformMode == 0 ){//flatten hierarchy
         jobString += L";flattenHierarchy=true";
         jobString += L";globalspace=false";
      }
      else if( transformMode == 1){//full hierarchy
         jobString += L";flattenHierarchy=false";
         jobString += L";globalspace=false";
      }
      else if( transformMode == 2){//bake in
         jobString += L";flattenHierarchy=true";
         jobString += L";globalspace=true";
      }

      Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
   }

   CStringArray jobs = jobString.Split(L"|");
   std::vector<AlembicWriteJob*> jobPtrs;

   double minFrame = 1000000.0;
   double maxFrame = -1000000.0;
   double maxSteps = 1;
   double maxSubsteps = 1;

   // for each job, check the arguments
   for(LONG i=0;i<jobs.GetCount();i++)
   {
      double frameIn = 1.0;
      double frameOut = 1.0;
      double frameSteps = 1.0;
      double frameSubSteps = 1.0;
      CString filename;
      bool transformCache = false;
      bool purepointcache = false;
      bool normals = true;
      bool uvs = true;
      bool facesets = true;
	   bool bindpose = true;
      bool dynamictopology = false;
      bool globalspace = false;
      bool flattenhierarchy = true;
      bool guidecurves = false;
      //CRefArray objects;

	  std::vector<AlembicWriteJob::Selectee> objects;

      // process all tokens of the job
      CStringArray tokens = jobs[i].Split(L";");
      for(LONG j=0;j<tokens.GetCount();j++)
      {
         CStringArray valuePair = tokens[j].Split(L"=");
         if(valuePair.GetCount()!=2)
         {
            Application().LogMessage(L"[ExocortexAlembic] Skipping invalid token: "+tokens[j],siWarningMsg);
            continue;
         }

         if(valuePair[0].IsEqualNoCase(L"in"))
            frameIn = (double)CValue(valuePair[1]);
         else if(valuePair[0].IsEqualNoCase(L"out"))
            frameOut = (double)CValue(valuePair[1]);
         else if(valuePair[0].IsEqualNoCase(L"step"))
            frameSteps = (double)CValue(valuePair[1]);
         else if(valuePair[0].IsEqualNoCase(L"substep"))
            frameSubSteps = (double)CValue(valuePair[1]);
         else if(valuePair[0].IsEqualNoCase(L"normals"))
            normals = (bool)CValue(valuePair[1]);
         else if(valuePair[0].IsEqualNoCase(L"uvs"))
            uvs = (bool)CValue(valuePair[1]);
         else if(valuePair[0].IsEqualNoCase(L"facesets"))
            facesets = (bool)CValue(valuePair[1]);
		   else if(valuePair[0].IsEqualNoCase(L"bindpose"))
            bindpose = (bool)CValue(valuePair[1]);
		   else if(valuePair[0].IsEqualNoCase(L"transformcache"))
            transformCache = (bool)CValue(valuePair[1]);
		   else if(valuePair[0].IsEqualNoCase(L"purepointcache"))
            purepointcache = (bool)CValue(valuePair[1]);
		   else if(valuePair[0].IsEqualNoCase(L"dynamictopology"))
            dynamictopology = (bool)CValue(valuePair[1]);
		   else if(valuePair[0].IsEqualNoCase(L"globalspace"))
            globalspace = (bool)CValue(valuePair[1]);
		   else if(valuePair[0].IsEqualNoCase(L"flattenhierarchy"))
            flattenhierarchy = (bool)CValue(valuePair[1]);
         else if(valuePair[0].IsEqualNoCase(L"guidecurves"))
            guidecurves = (bool)CValue(valuePair[1]);
         else if(valuePair[0].IsEqualNoCase(L"filename"))
            filename = CValue(valuePair[1]).GetAsText();
         else if(valuePair[0].IsEqualNoCase(L"objects"))
         {
            // try to find each object
            CStringArray objectStrings = valuePair[1].Split(L",");
            for(LONG k=0;k<objectStrings.GetCount();k++)
            {
               CRef objRef;
               objRef.Set(objectStrings[k]);
               if(!objRef.IsValid())
               {
                  Application().LogMessage(L"[ExocortexAlembic] Skipping object 'L"+objectStrings[k]+"', not found.",siWarningMsg);
                  continue;
               }
               objects.push_back(objRef);

               // ensure to add models as a flattened list
               // don't want to add all children automatically for now
               Model model(objRef);
               if(model.IsValid())
               {
                  CRefArray children = model.GetChildren();
                  for(LONG j=0;j<children.GetCount();j++)
                  {
                     X3DObject child(children[j]);
                     if(!child.IsValid())
                        continue;
                     CRefArray childChildren = child.GetChildren();
                     for(LONG l=0;l<childChildren.GetCount();l++)
                        children.Add(childChildren[l]);
                     objects.push_back(child.GetRef());
                  }
               }
            }
         }
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Skipping invalid token: "+tokens[j],siWarningMsg);
            continue;
         }
      }

      // check if we have incompatible subframes
      if(maxSubsteps > 1.0 && frameSubSteps > 1.0)
      {
         if(maxSubsteps > frameSubSteps)
         {
            double part = maxSubsteps / frameSubSteps;
            if(abs(part - floor(part)) > 0.001)
            {
               Application().LogMessage(L"[ExocortexAlembic] You cannot combine substeps "+CString(frameSubSteps)+L" and "+CString(maxSubsteps)+L" in one export. Aborting.",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(frameSubSteps > maxSubsteps )
         {
            double part = frameSubSteps / maxSubsteps;
            if(abs(part - floor(part)) > 0.001)
            {
               Application().LogMessage(L"[ExocortexAlembic] You cannot combine substeps "+CString(maxSubsteps)+L" and "+CString(frameSubSteps)+L" in one export. Aborting.",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
      }

      // remember the min and max values for the frames
      if(frameIn < minFrame) minFrame = frameIn;
      if(frameOut > maxFrame) maxFrame = frameOut;
      if(frameSteps > maxSteps) maxSteps = frameSteps;
      if(frameSteps > 1.0) frameSubSteps = 1.0;
      if(frameSubSteps > maxSubsteps) maxSubsteps = frameSubSteps;

      // check if we have a filename
      if(filename.IsEmpty())
      {
         // let's see if we are in interactive mode
         if(Application().IsInteractive())
         {
            CComAPIHandler toolkit;
            toolkit.CreateInstance(L"XSI.UIToolkit");
            CComAPIHandler filebrowser(toolkit.GetProperty(L"FileBrowser"));
            filebrowser.PutProperty(L"InitialDirectory",Application().GetActiveProject().GetPath());
            filebrowser.PutProperty(L"Filter",L"Alembic Files(*.abc)|*.abc||");
            CValue returnVal;
            filebrowser.Call(L"ShowSave",returnVal);
            filename = filebrowser.GetProperty(L"FilePathName").GetAsText();            
         }
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] No filename specified.",siErrorMsg);
            for(size_t k=0;k<jobPtrs.size();k++)
               delete(jobPtrs[k]);
            return CStatus::InvalidArgument;
         }
      }

      if(filename.IsEmpty() || !validate_filename_location(filename.GetAsciiString()))
      {
         Application().LogMessage(L"[ExocortexAlembic] cannot write file " + filename,siErrorMsg);
         for(size_t k=0;k<jobPtrs.size();k++)
            delete(jobPtrs[k]);
         return CStatus::Abort;
      }

      // construct the frames
      CDoubleArray frames;
      for(double frame=frameIn; frame<=frameOut; frame+=frameSteps / frameSubSteps)
         frames.Add(frame);

      AlembicWriteJob * job = new AlembicWriteJob(filename,objects,frames);
      job->SetOption(L"transformCache",transformCache);
      job->SetOption(L"exportNormals",normals);
      job->SetOption(L"exportUVs",uvs);
      job->SetOption(L"exportFaceSets",facesets);
	   job->SetOption(L"exportBindPose",bindpose);
      job->SetOption(L"exportPurePointCache",purepointcache);
      job->SetOption(L"exportDynamicTopology",dynamictopology);
      job->SetOption(L"indexedNormals",true);
      job->SetOption(L"indexedUVs",true);
      job->SetOption(L"globalSpace",globalspace);
      job->SetOption(L"flattenHierarchy",flattenhierarchy);
      job->SetOption(L"guideCurves",guidecurves);

      // check if the job is satifsied
      if(job->PreProcess() != CStatus::OK)
      {
         Application().LogMessage(L"[ExocortexAlembic] Job skipped. Not satisfied.",siErrorMsg);
         delete(job);
         continue;
      }

      // push the job to our registry
      Application().LogMessage(L"[ExocortexAlembic] Using WriteJob:"+jobs[i]);
      jobPtrs.push_back(job);
   }

   // compute the job count
   ULONG jobCount = 0;   
   ULONG objectCount = 0;
   for(size_t i=0;i<jobPtrs.size();i++) {
      jobCount += (ULONG)jobPtrs[i]->GetNbObjects() * (ULONG)jobPtrs[i]->GetFrames().size();
	  objectCount += (ULONG)jobPtrs[i]->GetNbObjects();
   }



   ProgressBar prog;
   prog = Application().GetUIToolkit().GetProgressBar();
   prog.PutCaption(L"Exporting "+CString(jobCount)+L" frames from " + CString(objectCount) + " objects...");
   prog.PutMinimum(0);
   prog.PutMaximum(jobCount);
   prog.PutValue(0);
   prog.PutCancelEnabled(true);
   prog.PutVisible(true);
	
   // now, let's run through all frames, and process the jobs
   CValueArray setFrameArgs;
   CValue setFrameResult;
   for(double frame = minFrame; frame<=maxFrame; frame += maxSteps / maxSubsteps)
   {
      setFrameArgs.Resize(2);
      setFrameArgs[0] = L"PlayControl.Current";
      setFrameArgs[1] = frame;
      Application().ExecuteCommand(L"SetValue",setFrameArgs,setFrameResult);

      setFrameArgs.Resize(1);
      setFrameArgs[0] = frame;
      Application().ExecuteCommand(L"Refresh",setFrameArgs,setFrameResult);

      bool canceled = false;
      for(size_t i=0;i<jobPtrs.size();i++)
      {
         CStatus status = jobPtrs[i]->Process(frame);
         if(status == CStatus::OK)
            prog.Increment((LONG)jobPtrs[i]->GetNbObjects());
         else if(status != CStatus::False)
         {
            for(size_t k=0;k<jobPtrs.size();k++)
               delete(jobPtrs[k]);
            return status;
         }

         if(prog.IsCancelPressed())
         {
            canceled = true;
            break;
         }
      }
      if(canceled)
         break;
   }

   prog.PutVisible(false);

   // delete all jobs
   for(size_t k=0;k<jobPtrs.size();k++)
      delete(jobPtrs[k]);

   // remove all known archives
   deleteAllArchives();

   return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_import_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"filename");
   oArgs.Add(L"normals");
   oArgs.Add(L"uvs");
   oArgs.Add(L"clusters");
   oArgs.Add(L"visibility");
   oArgs.Add(L"standins");
   oArgs.Add(L"bboxes");
   oArgs.Add(L"attach");
   oArgs.Add(L"identifiers");
	return CStatus::OK;
ESS_CALLBACK_END


bool hasMultipleSamples(Alembic::Abc::IObject object)
{
   return getNumSamplesFromObject(object) > 1;
}

ESS_CALLBACK_START(alembic_create_item_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"type");
   oArgs.Add(L"target");
   oArgs.Add(L"file");
   oArgs.Add(L"identifier");
   oArgs.Add(L"reattach");
   oArgs.Add(L"timecontrolprop");
   oArgs.Add(L"facesets");
   oArgs.Add(L"normals");
   oArgs.Add(L"uvs");
   oArgs.Add(L"bindpose");
	return CStatus::OK;
ESS_CALLBACK_END


enum alembicItemType{
   alembicItemType_xform,
   alembicItemType_camera,
   alembicItemType_polymesh_topo,
   alembicItemType_bbox,
   alembicItemType_polymesh,
   alembicItemType_crvlist_topo,
   alembicItemType_crvlist,
   alembicItemType_curves,
   alembicItemType_points,
   alembicItemType_metadata,
   alembicItemType_timecontrol,
   alembicItemType_visibility,
   alembicItemType_geomapprox,
   alembicItemType_standin,
   alembicItemType_nurbs,
   alembicItemType_none
};

std::map<std::string,alembicItemType> gItemTypeMap;

CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting,
   const CValueArray & args,
   CValue & returnVal
)
{
	ESS_PROFILE_SCOPE("alembic_create_item_Invoke");

	// fill the map in case it is empty
   if(gItemTypeMap.size() == 0)
   {
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_xform",alembicItemType_xform));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_camera",alembicItemType_camera));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_polymesh_topo",alembicItemType_polymesh_topo));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_bbox",alembicItemType_bbox));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_polymesh",alembicItemType_polymesh));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_crvlist_topo",alembicItemType_crvlist_topo));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_crvlist",alembicItemType_crvlist));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_curves",alembicItemType_curves));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_points",alembicItemType_points));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_metadata",alembicItemType_metadata));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_timecontrol",alembicItemType_timecontrol));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_visibility",alembicItemType_visibility));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_geomapprox",alembicItemType_geomapprox));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_standin",alembicItemType_standin));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_nurbs",alembicItemType_nurbs));
   }

   // query the item type from the map
   CString realType(type);
   realType.Lower();
   std::map<std::string,alembicItemType>::iterator it = gItemTypeMap.find(realType.GetAsciiString());
   alembicItemType itemType = alembicItemType_none;
   if(it != gItemTypeMap.end())
      itemType = it->second;

   // cast into the standard types
   X3DObject x3d(target);
   Primitive prim(target);

   // now let's find the real target for this
   CRef realTarget;
   { ESS_PROFILE_SCOPE("alembic_create_item_Invoke find_real_target");
   switch(itemType)
   {
      case alembicItemType_xform:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetKinematics().GetLocal().GetRef();
         else
         {
            KinematicState kine(target);
            if(kine.IsValid())
               realTarget = target;
            else
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      {
         if(x3d.IsValid())
         {
            Property visProp;
            if(itemType == alembicItemType_visibility)
               x3d.GetPropertyFromName(L"Visibility",visProp);
            else
            {
               x3d.GetPropertyFromName(L"GeomApprox",visProp);
            }
            realTarget = visProp.GetRef();
         }
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_camera:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetActivePrimitive().GetRef();
         else if(prim.IsValid())
            realTarget = prim.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(!Primitive(realTarget).GetType().IsEqualNoCase(L"camera"))
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_points:
      case alembicItemType_nurbs:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetActivePrimitive().GetRef();
         else if(prim.IsValid())
            realTarget = prim.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         // now check the type as well
         if(itemType == alembicItemType_polymesh_topo || itemType == alembicItemType_polymesh)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"polymsh"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_crvlist_topo || itemType == alembicItemType_crvlist)
         {
			CString type = Primitive(realTarget).GetType();
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"crvlist") && 
			   !Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud") &&
			   !Primitive(realTarget).GetType().IsEqualNoCase(L"hair"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_points || itemType == alembicItemType_curves)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_nurbs)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"surfmsh"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      case alembicItemType_metadata:
      case alembicItemType_timecontrol:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_standin:
      {
         CustomOperator alembicOp(target);
         ICETree alembicTree(target);
         if(!alembicOp.IsValid() && !alembicTree.IsValid())
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(!alembicOp.GetType().GetSubString(0,8).IsEqualNoCase(L"alembic_") && !alembicTree.GetName().GetSubString(0,4).IsEqualNoCase(L"abc_"))
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(alembicOp.IsValid())
            realTarget = alembicOp.GetRef();
         else
         {
            // loop for the first custom node
            CRefArray compounds = alembicTree.GetCompoundNodes();
            for(LONG j=0;j<compounds.GetCount();j++)
            {
               ICECompoundNode compound(compounds[j]);
               CRefArray nodes = compound.GetNodes();
               for(LONG k=0;k<nodes.GetCount();k++)
               {
                  CString nodeType = ICENode(nodes[k]).GetType();
                  if(nodeType.GetSubString(0,8).IsEqualNoCase(L"alembic_"))
                  {
                     realTarget = nodes[k];
                     break;
                  }
               }

               if(realTarget.IsValid())
                  break;
            }

            if(!realTarget.IsValid())
            {
               Application().LogMessage(L"[ExocortexAlembic] Could not find custom abc node on icetree '"+target.GetAsText()+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      default:
      {
         Application().LogMessage(L"[ExocortexAlembic] Unknown item type '"+type+L"'.",siErrorMsg);
         return CStatus::InvalidArgument;
      }
   }
   }

   // now validate the identifier if necessary
   Alembic::Abc::IObject abcObject;
   bool isAnimated = false;
   { ESS_PROFILE_SCOPE("alembic_create_item_Invoke validate_the_identifier");
   switch(itemType)
   {
      case alembicItemType_xform:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_metadata:
      case alembicItemType_points:
      case alembicItemType_geomapprox:
      case alembicItemType_nurbs:
      {
         abcObject = getObjectFromArchive(file,identifier);
         if(!abcObject.valid())
         {
            Application().LogMessage(L"[ExocortexAlembic] Identifier '"+identifier+L"' is not valid for given filename.",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         isAnimated = (itemType == alembicItemType_bbox) || (hasMultipleSamples(abcObject) && itemType != alembicItemType_geomapprox);
         break;
      }
      case alembicItemType_visibility:
      {
         abcObject = getObjectFromArchive(file,identifier);
         if(!abcObject.valid())
         {
            Application().LogMessage(L"[ExocortexAlembic] Identifier '"+identifier+L"' is not valid for given filename.",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         Alembic::AbcGeom::IVisibilityProperty visibilityProperty = 
            Alembic::AbcGeom::GetVisibilityProperty(abcObject);
         if(!visibilityProperty.valid())
         {
            return CStatus::InvalidArgument;
         }
         isAnimated = visibilityProperty.getNumSamples() > 1;
         break;
      }
      case alembicItemType_standin:
      default:
         break;
   }
   }

    // check if we have a timecontrol in the args
    CustomProperty timeControlProp;
    CRef timeControlRef;
    if(args.GetCount() > 0)
       timeControlRef = args[0];
    timeControlProp = timeControlRef;
	CValue setExprReturn;
    CValueArray setExprArgs(2);  
	CString expressionString;
    if(timeControlProp.IsValid())
    {
       setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
	   expressionString = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
    }

    { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator");
   // now create an operator...?
   switch(itemType)
   {
      case alembicItemType_xform:
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_nurbs:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_xxx");
		// for visibility, let's see if we should create an operator
         if(itemType == alembicItemType_visibility)
         {
            bool importVis = args[4];
            if(!importVis)
            {
               // this means skip the creation of the operator
               Alembic::AbcGeom::IVisibilityProperty visibilityProperty = 
                  Alembic::AbcGeom::GetVisibilityProperty(abcObject);
               if(visibilityProperty.valid())
               {
                  int rawVisibilityValue = visibilityProperty.getValue ( size_t(0) );
                  Alembic::AbcGeom::ObjectVisibility visibilityValue = Alembic::AbcGeom::ObjectVisibility ( rawVisibilityValue );

                  Property prop(realTarget);
                  switch(visibilityValue)
                  {
                     case Alembic::AbcGeom::kVisibilityVisible:
                     {
                        prop.PutParameterValue(L"viewvis",true);
                        prop.PutParameterValue(L"rendvis",true);
                        break;
                     }
                     case Alembic::AbcGeom::kVisibilityHidden:
                     {
                        prop.PutParameterValue(L"viewvis",false);
                        prop.PutParameterValue(L"rendvis",false);
                        break;
                     }
                     default:
                     {
                        break;
                     }
                  }
                  break;
               }
            }
         }

         // for xform, disable softimage scaling
         if(itemType == alembicItemType_xform)
            KinematicState(realTarget).PutParameterValue(L"siscaling",false);

         CustomOperator op;
         if(attachToExisting)
         {
            CRef opRef;
            opRef.Set(realTarget.GetAsText()+L"."+realType);
            op = opRef;
         }
         if(!op.IsValid())
         {
			 {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator CreateObject");
		    op = Application().GetFactory().CreateObject(realType);
			 }

		/*	 		// Duplicate arc 4 times and translate in y
		args.Resize(19);
		args[0] = arc;					// source object
		args[1] = (LONG)4;				// number of copies
		args[9] = (LONG)siApplyRepeatXForm;	// Xform
		args[18] = (double)1;			// Ty
		app.ExecuteCommand( L"Duplicate", args, outArg );*/
			 
			 { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator AddPorts");
            op.AddOutputPort(realTarget);
            op.AddInputPort(realTarget);
			 }

            siConstructionMode consMode = siConstructionModeModeling;
            if(itemType != alembicItemType_crvlist_topo && itemType != alembicItemType_polymesh_topo)
               consMode = siConstructionModeAnimation;
			 { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator Connect");
			
				op.Connect(consMode);
			 }
         }
 
         // setup the operator
         addRefArchive(file);
         op.PutParameterValue(L"path",file);
         op.PutParameterValue(L"identifier",identifier);

         // store the return value
         returnVal = op.GetRef();

         // if we are not a topo op, let's connect to the timecontrol
         bool receivesExpression = isAnimated;
         if(itemType == alembicItemType_crvlist_topo)
            receivesExpression = false;
         else if(itemType == alembicItemType_polymesh_topo)
         {
            // check if the compound has more than one sample on its facecounts
            Alembic::Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
            Alembic::Abc::IInt32ArrayProperty faceCountProp = Alembic::Abc::IInt32ArrayProperty(abcCompound,".faceCounts");
            if(faceCountProp.valid())
               receivesExpression = !faceCountProp.isConstant();
            else
               receivesExpression = false;
         }

         if(receivesExpression)
         {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator receivesExpression");

            // check if we have a timecontrol in the args
             if(timeControlProp.IsValid())
            {
				 //setExprArgs[0] = op.GetFullName()+L".time";
				 op.GetParameter("time").AddExpression( expressionString );
				//Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
            }
         }

         // if we are a polygon mesh topo op, oh dear
         if(itemType == alembicItemType_polymesh_topo && args.GetCount() > 3)
         {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo");

            bool importClusters = args[1];
            bool importNormals = args[2];
            bool importUvs = args[3];

            Alembic::AbcGeom::IPolyMesh abcMesh;
            Alembic::AbcGeom::ISubD abcSubD;
            if(Alembic::AbcGeom::IPolyMesh::matches(abcObject.getMetaData()))
               abcMesh = Alembic::AbcGeom::IPolyMesh(abcObject,Alembic::Abc::kWrapExisting);
            else
               abcSubD = Alembic::AbcGeom::ISubD(abcObject,Alembic::Abc::kWrapExisting);
            if(!abcMesh.valid() && !abcSubD.valid())
               return CStatus::OK;

            PolygonMesh meshGeo = Primitive(realTarget).GetGeometry();
            if(importClusters)
            {
        	  ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importClusters");
		       std::vector<std::string> faceSetNames;
               if(abcMesh.valid())
                  abcMesh.getSchema().getFaceSetNames(faceSetNames);
               else
                  abcSubD.getSchema().getFaceSetNames(faceSetNames);
               for(size_t j=0;j<faceSetNames.size();j++)
               {
                  if(attachToExisting)
                  {
                     if(meshGeo.GetClusters().GetItem(CString(faceSetNames[j].c_str())).IsValid())
                        continue;
                  }
                  Alembic::AbcGeom::IFaceSetSchema faceSet;
                  if(abcMesh.valid())
                     faceSet = abcMesh.getSchema().getFaceSet(faceSetNames[j]).getSchema();
                  else
                     faceSet = abcSubD.getSchema().getFaceSet(faceSetNames[j]).getSchema();
                  Alembic::AbcGeom::IFaceSetSchema::Sample faceSetSample = faceSet.getValue();
                  Alembic::Abc::Int32ArraySamplePtr faces = faceSetSample.getFaces();
                  CLongArray elements((LONG)faces->size());
                  for(size_t k=0;k<faces->size();k++)
                     elements[(LONG)k] = (LONG)faces->get()[k];
                  Cluster cluster;
                  meshGeo.AddCluster(L"poly",CString(faceSetNames[j].c_str()),elements,cluster);
               }
            }
            if(importNormals && abcMesh.valid())
            {
              ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importNormals");
		       Alembic::AbcGeom::IN3fGeomParam meshNormalsParam = abcMesh.getSchema().getNormalsParam();
               if(meshNormalsParam.valid())
               {
                  Alembic::Abc::N3fArraySamplePtr meshNormals = meshNormalsParam.getExpandedValue(0).getVals();

                  CRef clusterPropRef;
                  if(attachToExisting)
                     clusterPropRef.Set(realTarget.GetAsText()+L".cls.User_Normal_Cluster.User_Normal_Property");
                  if(!clusterPropRef.IsValid())
                  {
                     // create user normals
                     CValue createUserNormalReturnVal;
                     CValueArray createUserNormalArgs(1);
                     createUserNormalArgs[0] = Primitive(realTarget).GetParent3DObject().GetFullName();
                     Application().ExecuteCommand(L"CreateUserNormals",createUserNormalArgs,createUserNormalReturnVal);
                  }
                  ClusterProperty userNormalProp;
                  CRefArray clusters = meshGeo.GetClusters();
                  for(LONG j=0;j<clusters.GetCount();j++)
                  {
                     Cluster cluster(clusters[j]);
                     if(!cluster.GetType().IsEqualNoCase(L"sample"))
                        continue;
                     CRefArray props(cluster.GetLocalProperties());
                     for(LONG k=0;k<props.GetCount();k++)
                     {
                        ClusterProperty prop(props[k]);
                        if(prop.GetType().IsEqualNoCase(L"normal"))
                        {
                           userNormalProp = props[k];
                           break;
                        }
                     }
                     if(userNormalProp.IsValid())
                        break;
                  }
                  if(userNormalProp.IsValid())
                  {
                     // we found it, and we need to attach the op
                     CustomOperator op;
                     if(attachToExisting)
                     {
                        CRef opRef;
                        opRef.Set(userNormalProp.GetFullName()+L".alembic_normals");
                        op = opRef;
                     }
                     if(!op.IsValid())
                     {
                        op = Application().GetFactory().CreateObject(L"alembic_normals");
                        op.AddOutputPort(userNormalProp.GetRef());
                        op.AddInputPort(userNormalProp.GetRef());
                        op.AddInputPort(realTarget);
                        op.Connect();
                     }
                     addRefArchive(file);
                     op.PutParameterValue(L"path",file);
                     op.PutParameterValue(L"identifier",identifier);
                     if(!timeControlProp.IsValid())
                     {
                        CRef timeControlRef;
                        if(args.GetCount() > 0)
                           timeControlRef = args[0];
                        timeControlProp = timeControlRef;
                     }
                     if(timeControlProp.IsValid())
                     {
                        CValue setExprReturn;
                        CValueArray setExprArgs(2);
                        setExprArgs[0] = op.GetFullName()+L".time";
                        setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
                        Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
                     }
                  }
               }
            }
            if(importUvs)
            {
                ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importUvs");
				Alembic::AbcGeom::IV2fGeomParam meshUVsParam;
               if(abcMesh.valid())
                  meshUVsParam = abcMesh.getSchema().getUVsParam();
               else
                  meshUVsParam = abcSubD.getSchema().getUVsParam();
               if(meshUVsParam.valid())
               {
                  size_t numUVSamples = meshUVsParam.getNumSamples();
                  Alembic::Abc::V2fArraySamplePtr meshUVs = meshUVsParam.getExpandedValue(0).getVals();
                  if(meshUVs->size() > 0)
                  {
                     // check if we have a uv set names prop
                     CStringArray uvSetNames;
                     if(abcMesh.valid())
                     {
                        if ( abcMesh.getSchema().getPropertyHeader( ".uvSetNames" ) != NULL )
                        {
                           Alembic::Abc::IStringArrayProperty uvSetNamesProp = Alembic::Abc::IStringArrayProperty( abcMesh.getSchema(), ".uvSetNames" );
                           Alembic::Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                           for(size_t i=0;i<ptr->size();i++)
                              uvSetNames.Add(CString(ptr->get()[i].c_str()));
                        }
                     }
                     else
                     {
                        if ( abcSubD.getSchema().getPropertyHeader( ".uvSetNames" ) != NULL )
                        {
                           Alembic::Abc::IStringArrayProperty uvSetNamesProp = Alembic::Abc::IStringArrayProperty( abcSubD.getSchema(), ".uvSetNames" );
                           Alembic::Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                           for(size_t i=0;i<ptr->size();i++)
                              uvSetNames.Add(CString(ptr->get()[i].c_str()));
                        }
                     }
                     if(uvSetNames.GetCount() == 0)
                        uvSetNames.Add(L"Texture_Projection");

                     // for each uv set name
                     for(LONG uvI=0; uvI < uvSetNames.GetCount(); uvI++)
                     {
                        CRef clusterPropRef;
                        if(attachToExisting)
                           clusterPropRef.Set(realTarget.GetAsText()+L".cls.Texture_Coordinates_AUTO."+uvSetNames[uvI]);
                        if(!clusterPropRef.IsValid())
                        {
                           // create user normals
                           CValue createProjectionReturnVal;
                           CValueArray createProjectionArgs(5);
                           createProjectionArgs[0] = Primitive(realTarget).GetParent3DObject().GetFullName();
                           createProjectionArgs[1] = siTxtPureImplicit;
                           createProjectionArgs[2] = siTxtDefaultPlanarXY;
                           createProjectionArgs[3] = L"";
                           createProjectionArgs[4] = uvSetNames[uvI];
                           Application().ExecuteCommand(L"CreateProjection",createProjectionArgs,createProjectionReturnVal);
                        }
                        ClusterProperty uvProp;
                        CRefArray clusters = meshGeo.GetClusters();
                        for(LONG j=0;j<clusters.GetCount();j++)
                        {
                           Cluster cluster(clusters[j]);
                           if(!cluster.GetType().IsEqualNoCase(L"sample"))
                              continue;
                           CRefArray props(cluster.GetLocalProperties());
                           for(LONG k=0;k<props.GetCount();k++)
                           {
                              ClusterProperty prop(props[k]);
                              if(prop.GetType().IsEqualNoCase(L"uvspace") && prop.GetName().IsEqualNoCase(uvSetNames[uvI]))
                              {
                                 uvProp = props[k];
                                 break;
                              }
                           }
                           if(uvProp.IsValid())
                              break;
                        }
                        if(uvProp.IsValid())
                        {
                           // check if this alembic file has a uv options property
                           bool hasUvOptions = false;
                           if(abcMesh.valid())
                              hasUvOptions = abcMesh.getSchema().getPropertyHeader( ".uvOptions" ) != NULL;
                           else
                              hasUvOptions = abcSubD.getSchema().getPropertyHeader( ".uvOptions" ) != NULL;
                           if(hasUvOptions)
                           {
                              Alembic::Abc::IFloatArrayProperty prop;
                              if(abcMesh.valid())
                                 prop = Alembic::Abc::IFloatArrayProperty( abcMesh.getSchema(), ".uvOptions" );
                              else
                                 prop = Alembic::Abc::IFloatArrayProperty( abcSubD.getSchema(), ".uvOptions" );

                              // if the prop stores any data
                              if(prop.getNumSamples() > 0)
                              {
                                 Alembic::Abc::FloatArraySamplePtr ptr = prop.getValue(0);
                                 if(ptr->size() > 2 * uvI + 1)
                                 {
                                    bool uWrap = ptr->get()[uvI * 2 + 0] != 0.0f;
                                    bool vWrap = ptr->get()[uvI * 2 + 1] != 0.0f;

                                    CRefArray children = uvProp.GetNestedObjects();
                                    for(LONG i=0; i<children.GetCount(); i++)
                                    {
                                       ProjectItem child(children.GetItem(i));
                                       CString type = child.GetType();
                                       if(type == L"uvprojdef")
                                       {
                                          child.GetParameter(L"wrap_u").PutValue(uWrap);
                                          child.GetParameter(L"wrap_v").PutValue(vWrap);
                                          break;
                                       }
                                    }
                                 }
                              }
                           }

                           // we found it, and we need to attach the op
                           CustomOperator op;
                           if(attachToExisting)
                           {
                              CRef opRef;
                              opRef.Set(uvProp.GetFullName()+L".alembic_uvs");
                              op = opRef;
                           }
                           if(!op.IsValid())
                           {
                              op = Application().GetFactory().CreateObject(L"alembic_uvs");
                              op.AddOutputPort(uvProp.GetRef());
                              op.AddInputPort(uvProp.GetRef());
                              op.AddInputPort(realTarget);
                              op.Connect();
                           }
                           addRefArchive(file);
                           op.PutParameterValue(L"path",file);
                           op.PutParameterValue(L"identifier",identifier+CString(L":")+CString(uvI));
                           if(numUVSamples > 1)
                           {
                              CValue setExprReturn;
                              CValueArray setExprArgs(2);
                              setExprArgs[0] = op.GetFullName()+L".time";
                              setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
                              Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
                           }
                        }
                     }
                  }
               }
            }
         }

         break;
      }
      case alembicItemType_curves:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_curves");
		// let's setup the ICE tree to load it
         ICETree iceTree;
         CValueArray treeArgs(2);
         CValue treeReturnVal;
         if(attachToExisting)
         {
            CRef treeRef;
            treeRef.Set(realTarget.GetAsText()+L".ABC_Load_Curves");
            iceTree = treeRef;
         }
         if(!iceTree.IsValid())
         {
            treeArgs[0] = L"ABC Load Curves";
            treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
            Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
            iceTree = (CRef)treeReturnVal;
         }
         ICECompoundNode node = iceTree.GetCompoundNodes()[0];
         treeArgs[0] = node.GetFullName()+L".path_string";
         treeArgs[1] = file;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         treeArgs[0] = node.GetFullName()+L".identifier_string";
         treeArgs[1] = identifier;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         if(isAnimated)
         {
            // check if we have a timecontrol in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            CustomProperty timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               treeArgs[0] = node.GetFullName()+L".TimeControl";
               treeArgs[1] = timeControlProp.GetFullName();
               Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
            }
         }

         // store the return value
         returnVal = iceTree.GetRef();
         break;
      }
      case alembicItemType_points:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_points");
				// let's setup the ICE tree to load it
         ICETree iceTree;
         CValueArray treeArgs(2);
         CValue treeReturnVal;

         // we need to check if we have instances....
         Alembic::AbcGeom::IPoints abcPoints(abcObject,Alembic::Abc::kWrapExisting);
         if(!abcPoints.valid())
            return CStatus::OK;

		 Alembic::Abc::IStringArrayProperty shapeInstanceNamesProp;
         if ( getArbGeomParamPropertyAlembic(abcPoints, "instancenames", shapeInstanceNamesProp) )
         {
            if(shapeInstanceNamesProp.getNumSamples() > 0)
            {
               Alembic::Abc::StringArraySamplePtr shapeInstanceNamesPtr = shapeInstanceNamesProp.getValue(shapeInstanceNamesProp.getNumSamples()-1);
               if(shapeInstanceNamesPtr->size() > 0)
               {
                  if(attachToExisting)
                  {
                     CRef treeRef;
                     treeRef.Set(realTarget.GetAsText()+L".ABC_Instance_Shapes");
                     iceTree = treeRef;
                  }
                  if(!iceTree.IsValid())
                  {
                     treeArgs[0] = L"ABC Instance Shapes";
                     treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
                     Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
                     iceTree = (CRef)treeReturnVal;
                  }

                  for(size_t j=0;j<shapeInstanceNamesPtr->size();j++)
                  {
                     std::string instanceIdentifier = shapeInstanceNamesPtr->get()[j];
					 //replace spaces with underscores
					 for(int c=0; c<instanceIdentifier.size(); c++){
						 if(instanceIdentifier[c] == ' '){
                             instanceIdentifier[c] = '_';
						 }
					 }
                     CString fullName = getFullNameFromIdentifier(instanceIdentifier);
                     treeArgs[0] = iceTree.GetFullName()+L".ABC_Instance_Shapes.Reference"+CString((LONG)j);
                     treeArgs[1] = fullName;
                     Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);

                     // also check if we have this object in the scene
                     if(hasStandinSupport())
                     {
                        CRef ref;
                        ref.Set(fullName);
                        X3DObject x3d(ref);
                        if(x3d.IsValid())
                        {
                           // disable deferred loading on the instance sources
                           CRef standinPropRef;
                           standinPropRef.Set(fullName+L".arnold_standin");
                           Property prop(standinPropRef);
                           if(prop.IsValid())
                              prop.PutParameterValue(L"deferredLoading",false);

						   // enable hiding the instance masters
                           CRef visPropRef;
                           visPropRef.Set(fullName+L".visibility");
                           prop = Property(visPropRef);
                           if(prop.IsValid())
                              prop.PutParameterValue(L"hidemaster",true);
                        }
                     }
                  }
               }
            }
         }

         if(attachToExisting)
         {
            CRef treeRef;
            treeRef.Set(realTarget.GetAsText()+L".ABC_Load_Points");
            iceTree = treeRef;
         }
         if(!iceTree.IsValid())
         {
            treeArgs[0] = L"ABC Load Points";
            treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
            Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
            iceTree = (CRef)treeReturnVal;
         }

         ICECompoundNode node = iceTree.GetCompoundNodes()[0];
         treeArgs[0] = node.GetFullName()+L".path_string";
         treeArgs[1] = file;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         treeArgs[0] = node.GetFullName()+L".identifier_string";
         treeArgs[1] = identifier;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         if(isAnimated)
         {
            // check if we have a timeControl in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            CustomProperty timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               treeArgs[0] = node.GetFullName()+L".TimeControl";
               treeArgs[1] = timeControlProp.GetFullName();
               Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
            }
         }

         // store the return value
         returnVal = iceTree.GetRef();
         break;
      }
      case alembicItemType_metadata:
      {
			ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_metadata");
		Alembic::Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
         if ( abcCompound.getPropertyHeader( ".metadata" ) == NULL )
            break;

         Alembic::Abc::IStringArrayProperty metaDataProp = Alembic::Abc::IStringArrayProperty( abcCompound, ".metadata" );
         Alembic::Abc::StringArraySamplePtr metaDataPtr = metaDataProp.getValue(0);
         if(metaDataPtr->size() != 20)
            break;

         // check if we already have the metadataprop
         CustomProperty xsiProp;
         CRefArray props = x3d.GetLocalProperties();
         for(LONG i=0;i<props.GetCount();i++)
         {
            CustomProperty prop(props[i]);
            if(!prop.IsValid())
               continue;
            if(!prop.GetType().IsEqualNoCase(L"alembic_metadata"))
               continue;
            xsiProp = prop;
            break;
         }
         if(!xsiProp.IsValid())
            xsiProp = x3d.AddProperty(L"alembic_metadata");

         // set all values
         size_t offset = 0;
         for(LONG i=0;i<10;i++)
         {
            xsiProp.PutParameterValue(L"name"+CString(i),CString(metaDataPtr->get()[offset++].c_str()));
            xsiProp.PutParameterValue(L"value"+CString(i),CString(metaDataPtr->get()[offset++].c_str()));
         }

         // store the return value
         returnVal = xsiProp.GetRef();
         break;
      }
      case alembicItemType_timecontrol:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_timecontrol");
		 CValueArray setExprArgs(2);
         CValue setExprReturn;
         CustomProperty timeControl = (CustomProperty) x3d.AddProperty(L"alembic_timecontrol");

         // prepare values for the setexpr command
         setExprArgs[0] = timeControl.GetFullName()+L".current";
         setExprArgs[1] = L"T";
         Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);

         // store the return value
         returnVal = timeControl.GetRef();
         break;
      }
      case alembicItemType_standin:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_standin");
		 // create an arnold property on the x3d if we don't have it yet!
         if(!hasStandinSupport())
         {
            Application().LogMessage(L"[ExocortexAlembic] There is no standin support. Please use a renderer supported standins.",siErrorMsg);
            return CStatus::InvalidArgument;
         }

         X3DObject sourceX3D = ProjectItem(realTarget).GetParent3DObject();
         CString projectItemName = ProjectItem(realTarget).GetFullName();
         CString sourceX3DFullName = sourceX3D.GetFullName();

         // let's see if we have the standin property already
         CustomProperty arnoldProp;
         CRef propRef;
         propRef.Set(sourceX3D.GetFullName()+L".arnold_standin");
         if(propRef.IsValid())
         {
            arnoldProp = CustomProperty(propRef);
         }
         else
         {
            arnoldProp = sourceX3D.AddProperty(L"arnold_standin",false);
         }

         // now check if the operator alrady exists
         CRef opRef;
         opRef.Set(arnoldProp.GetFullName()+L".alembic_standinop");
         if(!opRef.IsValid())
         {
            CustomOperator op = Application().GetFactory().CreateObject(L"alembic_standinop");
            op.AddOutputPort(arnoldProp.GetRef());
            op.AddInputPort(realTarget);
            op.Connect();

            // create the timecontrol expression
            // check if we have a timecontrol in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            Property timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               CValue setExprReturn;
               CValueArray setExprArgs(2);
               setExprArgs[0] = op.GetFullName()+L".time";
               setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
               Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
            }
         }

         break;
      }
      default:
         break;
   }
   }

   return CStatus::OK;
}


CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting,
   const CValueArray & args
)
{
	CValue returnVal;
	alembic_create_item_Invoke( type, target, file, identifier, attachToExisting, args, returnVal );
	return CStatus::OK;
}

CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting
)
{
	CValueArray args(0);
	alembic_create_item_Invoke( type, target, file, identifier, attachToExisting, args );
	return CStatus::OK;
}




ESS_CALLBACK_START(alembic_create_item_Execute, CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
   CString type = args[0];
   CRef target = args[1];
   CString file = args[2];
   CString identifier = args[3];
   bool reattach = args[4];
   CValueArray additionalArgs;
   for(LONG i=5;i<args.GetCount();i++)
      additionalArgs.Add(args[i]);
   CValue returnVal;
   CStatus result = alembic_create_item_Invoke(type,target,file,identifier,reattach,additionalArgs,returnVal);
   ctxt.PutAttribute(L"ReturnValue",returnVal);
   return result;
ESS_CALLBACK_END


void createTransform( Alembic::Abc::IObject& iObj, CRef& parentNode, CRef& newNode, CString& filename, bool attachToExisting, CValueArray& createItemArgs)
{
   X3DObject parentX3DObject(parentNode);
   CString name = truncateName(iObj.getName().c_str());

   if(Alembic::AbcGeom::IXform::matches(iObj.getMetaData()))
   {
      // check if this xform has xform children (is is model in this case)
      size_t nbTransformChildren = 0;
      for(size_t j=0;j<iObj.getNumChildren();j++)
      {
         if(Alembic::AbcGeom::IXform::matches(iObj.getChild(j).getMetaData()))
            nbTransformChildren++;
      }

      if(nbTransformChildren == iObj.getNumChildren())
      {
	     Model model;
		 CRef nodeRef;
         if(attachToExisting)
         {
		   ESS_PROFILE_SCOPE("attachToExisting");
            CRef modelRef;
            modelRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
            model = modelRef;

            if(!model.GetType().IsEqualNoCase(L"#model"))
               model.ResetObject();

            newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));

			nodeRef = model.GetRef();
         }
         if(!model.IsValid())
         {
			 Null null;
			 CRef nullRef;
			 nullRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
			null = nullRef;
            parentX3DObject.AddNull(name,null);
            nameMapAdd(iObj.getFullName().c_str(),null.GetFullName());
            //newNode = model.GetActivePrimitive().GetRef();
            newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
			nodeRef = null.GetRef();
         }

         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata",nodeRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load xform
         alembic_create_item_Invoke(L"alembic_xform",nodeRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
         
         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility",nodeRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
      }
   }
}

void createShape( Alembic::Abc::IObject& iObj, CRef& parentNode, CRef& newNode, CString& filename, bool attachToExisting, bool importStandins, bool importBboxes, bool wasMerged, CValueArray& createItemArgs)
{
   X3DObject parentX3DObject(parentNode);
   CString name = truncateName(iObj.getName().c_str());
   Alembic::Abc::IObject parent = iObj.getParent();

   // after dealing with transforms, let's deal with all shape types
   if(Alembic::AbcGeom::ICamera::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ICamera");
      // let's create a camera
      Camera camera;
      if(attachToExisting)
      {
	   ESS_PROFILE_SCOPE("attachToExisting");
         CRef cameraRef;
         cameraRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
         camera = cameraRef;
         if(!camera.GetType().IsEqualNoCase(L"camera"))
            camera.ResetObject();

         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }
      if(!camera.IsValid())
      {
         parentX3DObject.AddCamera(L"Camera",name,camera);
         nameMapAdd(iObj.getFullName().c_str(),camera.GetFullName());
         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }

      // delete the interest
      CValueArray deleteArgs(1);
      deleteArgs[0] = camera.GetInterest().GetFullName();
      CValue setExprReturn;
      Application().ExecuteCommand(L"DeleteObj",deleteArgs,setExprReturn);

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",camera.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // let's setup the xform op
      if(Alembic::AbcGeom::IXform::matches(parent.getMetaData()) && wasMerged)
         alembic_create_item_Invoke(L"alembic_xform",camera.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);
      
      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",camera.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // load camera
      alembic_create_item_Invoke(L"alembic_camera",camera.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
   }
   else if(Alembic::AbcGeom::IPolyMesh::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import IPolyMesh");

      X3DObject meshObj;
      if(attachToExisting)
      {
	   ESS_PROFILE_SCOPE("attachToExisting");
         CRef meshRef;
         meshRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
         meshObj = meshRef;

         if(!meshObj.GetType().IsEqualNoCase(L"PolyMsh"))
            meshObj.ResetObject();

         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }
      if(!meshObj.IsValid())
      {
         XSI::CStatus status;
         if(importBboxes)
            status = parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,meshObj);
         else
            status = parentX3DObject.AddPrimitive(L"EmptyPolygonMesh",name,meshObj);
         nameMapAdd(iObj.getFullName().c_str(),meshObj.GetFullName());

         if(!status.Succeeded()){
            ESS_LOG_ERROR(status.GetDescription().GetAsciiString());
         }

         ESS_LOG_WARNING(iObj.getFullName());
         ESS_LOG_WARNING(getFullNameFromIdentifier(iObj.getFullName()).GetAsciiString());
         status = newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
         if(!status.Succeeded()){
            ESS_LOG_WARNING(status.GetDescription().GetAsciiString());
         }
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // create the topo op
      CRef returnOpRef;
      if(!importBboxes && isAlembicMeshTopology(&iObj))
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_polymesh_topo",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // let's setup the xform op
      if(Alembic::AbcGeom::IXform::matches(parent.getMetaData()) && wasMerged)
         alembic_create_item_Invoke(L"alembic_xform",meshObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);
      
      // let's setup the positions op
      if(importBboxes)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }
      else
      {
         // only add the point position operator if we don't have dynamic topology
         bool receivesExpression = isAlembicMeshTopoDynamic( & ( iObj ) );
         
         if(!receivesExpression)
         {
            Alembic::AbcGeom::IPolyMesh abcMesh = Alembic::AbcGeom::IPolyMesh(iObj,Alembic::Abc::kWrapExisting);
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_polymesh",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid())
         alembic_create_item_Invoke(L"alembic_standin",returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
   }
   else if(Alembic::AbcGeom::ISubD::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ISubD");
      X3DObject meshObj;
      if(attachToExisting)
      {
	   ESS_PROFILE_SCOPE("attachToExisting");
         CRef meshRef;
         meshRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
         meshObj = meshRef;

         if(!meshObj.GetType().IsEqualNoCase(L"PolyMsh"))
            meshObj.ResetObject();

         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }
      if(!meshObj.IsValid())
      {
         if(importBboxes)
            parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,meshObj);
         else
            parentX3DObject.AddPrimitive(L"EmptyPolygonMesh",name,meshObj);
         nameMapAdd(iObj.getFullName().c_str(),meshObj.GetFullName());
         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }

      // make the geometry approx local
      CValue makeLocalReturn;
      CValueArray makeLocalArgs(2);
      makeLocalArgs[0] = meshObj.GetFullName()+L".geomapprox";
      makeLocalArgs[1] = siNodePropagation;
      Application().ExecuteCommand(L"MakeLocal",makeLocalArgs,makeLocalReturn);

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // create the topo op
      CRef returnOpRef;
      if(!importBboxes)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_polymesh_topo",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // load geometryapprox
      if(!importBboxes)
         alembic_create_item_Invoke(L"alembic_geomapprox",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // let's setup the xform op
      if(Alembic::AbcGeom::IXform::matches(parent.getMetaData()) && wasMerged)
         alembic_create_item_Invoke(L"alembic_xform",meshObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);
      
      // let's setup the positions op
      if(importBboxes)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }
      else
      {
         // only add the point position operator if we don't have dynamic topology
         Alembic::AbcGeom::ISubD abcSubD = Alembic::AbcGeom::ISubD(iObj,Alembic::Abc::kWrapExisting);
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_polymesh",meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid())
         alembic_create_item_Invoke(L"alembic_standin",returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
   }
   else if(Alembic::AbcGeom::INuPatch::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import INuPatch");
      X3DObject nurbsObj;
      if(attachToExisting)
      {
	   ESS_PROFILE_SCOPE("attachToExisting");
         CRef nurbsRef;
         nurbsRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
         nurbsObj = nurbsRef;
         if(!nurbsObj.GetType().IsEqualNoCase(L"surfmsh"))
            nurbsObj.ResetObject();
         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }
      if(!nurbsObj.IsValid())
      {
         // warn
         Application().LogMessage(L"[ExocortexAlembic] Skipping nurbs '"+name+L"', nurbs object not found in scene.",siWarningMsg);
      }
      else
      {
         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata",nurbsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // let's setup the xform op
         if(Alembic::AbcGeom::IXform::matches(parent.getMetaData()) && wasMerged)
            alembic_create_item_Invoke(L"alembic_xform",nurbsObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);
         
         alembic_create_item_Invoke(L"alembic_nurbs",nurbsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }
   }
   else if(Alembic::AbcGeom::ICurves::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ICurves");
      // let's create a crvlist
      Alembic::AbcGeom::ICurves curveIObject(iObj,Alembic::Abc::kWrapExisting);
      Alembic::AbcGeom::ICurvesSchema curveSchema = curveIObject.getSchema();
      Alembic::AbcGeom::ICurvesSchema::Sample curveSample = curveSchema.getValue();

      // check for valid curve types...!
      if(curveSample.getType() != Alembic::AbcGeom::ALEMBIC_VERSION_NS::kLinear &&
         curveSample.getType() != Alembic::AbcGeom::ALEMBIC_VERSION_NS::kCubic)
      {
         Application().LogMessage(L"[ExocortexAlembic] Skipping curve '"+name+L"', invalid curve type.",siWarningMsg);
         return;
      }

      // now let's check if we are looking at a curves node with color and radii

	 bool useParticles = true;
	 {
		 Alembic::Abc::IFloatArrayProperty propRadius;
		 if( ! getArbGeomParamPropertyAlembic( curveIObject, "radius", propRadius ) ) {
			 useParticles = false;
		 }
		 Alembic::Abc::IC4fArrayProperty propColor;
		 if( ! getArbGeomParamPropertyAlembic( curveIObject, "color", propColor ) ) {
			 useParticles = false;
		 } 
	 }
      /*bool useParticles = curveSchema.getPropertyHeader( ".radius" ) != NULL || curveSchema.getPropertyHeader( ".color" ) != NULL;
      if(useParticles)
      {
         if( curveSchema.getPropertyHeader( ".radius" ) != NULL )
         {
            Alembic::Abc::IFloatArrayProperty prop = Alembic::Abc::IFloatArrayProperty( curveSchema, ".radius" );
            if(!prop.valid())
               useParticles = false;
            else if(prop.getNumSamples() == 0)
               useParticles = false;
         }
         else if( curveSchema.getPropertyHeader( ".color" ) != NULL )
         {
            Alembic::Abc::IC4fArrayProperty prop = Alembic::Abc::IC4fArrayProperty( curveSchema, ".color" );
            if(!prop.valid())
               useParticles = false;
            else if(prop.getNumSamples() == 0)
               useParticles = false;
         }
      }*/

      if (useParticles)
      {
         X3DObject pointsObj;
         if(attachToExisting)
         {
 		   ESS_PROFILE_SCOPE("attachToExisting");
           CRef pointsRef;
            pointsRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
            pointsObj = pointsRef;
            if(!pointsObj.GetType().IsEqualNoCase(L"pointcloud"))
               pointsObj.ResetObject();

            newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
         }
         if(!pointsObj.IsValid())
         {
            if(importBboxes)
               parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,pointsObj);
            else
               parentX3DObject.AddPrimitive(L"PointCloud",name,pointsObj);
            nameMapAdd(iObj.getFullName().c_str(),pointsObj.GetFullName());
            newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
         }

         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata",pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility",pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load curves
         CRef returnOpRef;
         if(importBboxes)
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_bbox",pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
         else
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_curves",pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }

         // let's setup the xform op
         if(Alembic::AbcGeom::IXform::matches(parent.getMetaData()) && wasMerged)
            alembic_create_item_Invoke(L"alembic_xform",pointsObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);

         // load standin property
         if(importStandins && returnOpRef.IsValid())
            alembic_create_item_Invoke(L"alembic_standin",returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
      }
      else
      {
         X3DObject curveObj;
         if(attachToExisting)
         {
           ESS_PROFILE_SCOPE("attachToExisting");
            CRef curveRef;
            curveRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
            curveObj = curveRef;
            if(!curveObj.GetType().IsEqualNoCase(L"crvlist") && !curveObj.GetType().IsEqualNoCase(L"hair"))
               curveObj.ResetObject();

            newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
         }
         if(!curveObj.IsValid())
         {
            if(importBboxes)
               parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,curveObj);
            else
               parentX3DObject.AddNurbsCurveList(CNurbsCurveDataArray(),siSINurbs,name,curveObj);
            nameMapAdd(iObj.getFullName().c_str(),curveObj.GetFullName());
            newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
         }

         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata",curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility",curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load curve topo if it's not hair because that will already have desired topology if it exists
         if(!importBboxes && !curveObj.GetType().IsEqualNoCase(L"hair"))
            alembic_create_item_Invoke(L"alembic_crvlist_topo",curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load curve anim
         CRef returnOpRef;
         if(importBboxes)
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_bbox",curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
         else
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_crvlist",curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }

         // allow stretching as there may have been dynamics applied to the hair
         if( curveObj.GetType().IsEqualNoCase(L"hair"))
         {
            curveObj.GetActivePrimitive().PutParameterValue(L"AllowStretch", true);
         }

         // let's setup the xform op
         if(Alembic::AbcGeom::IXform::matches(parent.getMetaData()) && wasMerged)
            alembic_create_item_Invoke(L"alembic_xform",curveObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);

         // load standin property
         if(importStandins && returnOpRef.IsValid())
            alembic_create_item_Invoke(L"alembic_standin",returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
      }
   }
   else if(Alembic::AbcGeom::IPoints::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import IPoints");
      Alembic::AbcGeom::IPoints pointsIObject(iObj,Alembic::Abc::kWrapExisting);
      Alembic::AbcGeom::IPointsSchema pointsSchema = pointsIObject.getSchema();
      Alembic::AbcGeom::IPointsSchema::Sample pointsSample = pointsSchema.getValue();

      X3DObject pointsObj;
      if(attachToExisting)
      {
         ESS_PROFILE_SCOPE("attachToExisting");
         CRef pointsRef;
         pointsRef.Set(getFullNameFromIdentifier(iObj.getFullName()));
         pointsObj = pointsRef;
         if(!pointsObj.GetType().IsEqualNoCase(L"pointcloud"))
            pointsObj.ResetObject();

         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }
      if(!pointsObj.IsValid())
      {
         if(importBboxes)
            parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,pointsObj);
         else
            parentX3DObject.AddPrimitive(L"PointCloud",name,pointsObj);
         nameMapAdd(iObj.getFullName().c_str(),pointsObj.GetFullName());
         newNode.Set(getFullNameFromIdentifier(iObj.getFullName()));
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // let's setup the xform op
      if(Alembic::AbcGeom::IXform::matches(parent.getMetaData()) && wasMerged)
         alembic_create_item_Invoke(L"alembic_xform",pointsObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);

      // apply the ice tree
      CRef returnOpRef;
      if(importBboxes) {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox",pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      } else {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_points",pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid())
         alembic_create_item_Invoke(L"alembic_standin",returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
   }
   else{
      ESS_LOG_WARNING("Unsupported type.");
   }
}



struct stackElement
{
   Alembic::Abc::IObject iObj;
   CRef parentNode;

   stackElement(Alembic::Abc::IObject iObj):iObj(iObj)
   {}
   stackElement(Alembic::Abc::IObject iObj, CRef parent):iObj(iObj), parentNode(parent)
   {}

};

ESS_CALLBACK_START(alembic_import_Execute, CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
	ESS_PROFILE_SCOPE("alembic_import_Execute");

   // take care of the filename
   CString filename = (CString)args[0].GetAsText();
   if(filename.IsEmpty())
   {
	  // let's see if we are in interactive mode
      if(Application().IsInteractive())
      {
         CComAPIHandler toolkit;
         toolkit.CreateInstance(L"XSI.UIToolkit");
         CComAPIHandler filebrowser(toolkit.GetProperty(L"FileBrowser"));
         filebrowser.PutProperty(L"InitialDirectory",Application().GetActiveProject().GetPath());
         filebrowser.PutProperty(L"Filter",L"Alembic Files(*.abc)|*.abc||");
         CValue returnVal;
         filebrowser.Call(L"ShowOpen",returnVal);
         filename = filebrowser.GetProperty(L"FilePathName").GetAsText();
         if(filename.IsEmpty())
            return CStatus::Abort;
      }
      else
      {
         Application().LogMessage(L"[ExocortexAlembic] No filename specified.",siErrorMsg);
         return CStatus::InvalidArgument;
      }
   }
   Application().LogMessage(L"[ExocortexAlembic] filename used: "+filename);

   // check if we have arguments
   if(args[1].GetAsText().IsEmpty())
   {
      // let's setup the property
      CustomProperty settings;
      settings = Application().GetActiveSceneRoot().AddProperty(L"alembic_import_settings");

      // inspect it
      CValueArray inspectArgs(5);
      CValue inspectResult;
      inspectArgs[0] = settings.GetFullName();
      inspectArgs[1] = L"";
      inspectArgs[2] = L"Import Settings";
      inspectArgs[3] = siModal;
      inspectArgs[4] = false;
      Application().ExecuteCommand(L"InspectObj",inspectArgs,inspectResult);
      
      // prepare for deletion
      inspectArgs.Resize(1);
      inspectArgs[0] = settings.GetFullName();
      if((bool)inspectResult)
      {
         Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
         return CStatus::Abort;
      }

      // retrieve the options
      args[1] = settings.GetParameterValue(L"normals");
      args[2] = settings.GetParameterValue(L"uvs");
      args[3] = settings.GetParameterValue(L"facesets");
      args[4] = settings.GetParameterValue(L"visibility");
      if(hasStandinSupport())
      {
         LONG standinsValue = settings.GetParameterValue(L"standins");
         args[5] = standinsValue > 0;
         args[6] = standinsValue == 2;
      }
      else
      {
         args[5] = false;
         args[6] = false;
      }
      args[7] = settings.GetParameterValue(L"attach");

      Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
   }

   // let's try to read this
   Alembic::Abc::IArchive* archive = NULL;
   try{
      CString resolvedPath = CUtils::ResolveTokenString(filename,XSI::CTime(),false);
      archive = new Alembic::Abc::IArchive( Alembic::AbcCoreHDF5::ReadArchive(), resolvedPath.GetAsciiString() );
   }
   catch(Alembic::Util::Exception& e){
      std::string exc(e.what());
      ESS_LOG_ERROR("[alembic] Error reading file: "<<e.what());
      return CStatus::Fail;
   }
   catch(...){
      ESS_LOG_ERROR("[alembic] Error reading file.");
      return CStatus::Fail;
   }

   // also precap the filename with the project token just in case
   CString projectPath = Application().GetActiveProject().GetPath();
   for(ULONG i=0;i<filename.Length();i++)
   {
      if(filename.GetAt(i) == '\\')
         filename = filename.GetSubString(0,i)+L"/"+filename.GetSubString(i+1,10000);
   }
   for(ULONG i=0;i<projectPath.Length();i++)
   {
      if(projectPath.GetAt(i) == '\\')
         projectPath = projectPath.GetSubString(0,i)+L"/"+projectPath.GetSubString(i+1,10000);
   }
   if(filename.GetSubString(0,projectPath.Length()) == projectPath)
   {
      filename = L"[project path]"+filename.GetSubString(projectPath.Length(),10000);
   }

   bool importNormals = (bool)args[1];
   bool importUVs = (bool)args[2];
   bool importClusters = (bool)args[3];
   bool importVisibility = (bool)args[4];
   bool importStandins = (bool)args[5];
   bool importBboxes = (bool)args[6];
   bool attachToExisting = (bool)args[7];

   // let's check the identifier list
   CString identifierListStr = args[8].GetAsText();
   std::map<std::string,bool> identifierMap;
   if(!identifierListStr.IsEmpty())
   {
      CStringArray identifiers = identifierListStr.Split(L",");
      for(LONG i=0;i<identifiers.GetCount();i++)
      {
         while(identifiers[i].GetAt(0) == ' ')
            identifiers[i] = identifiers[i].GetSubString(1,1000000);
         while(identifiers[i].GetAt(identifiers[i].Length()-1) == ' ')
            identifiers[i] = identifiers[i].GetSubString(0,identifiers[i].Length()-1);
         identifierMap.insert(std::pair<std::string,bool>(identifiers[i].GetAsciiString(),true));
      }
   }

   // create the timecontrol
   CustomProperty timeControl;
   if(attachToExisting)
   {
      CRef timeRef;
      timeRef.Set(L"alembic_timecontrol");
      timeControl = timeRef;
   }
   CValueArray setExprArgs(2);
   CValue setExprReturn;
   if(!timeControl.IsValid())
   {
      timeControl = Application().GetActiveSceneRoot().AddProperty(L"alembic_timecontrol");

      // prepare values for the setexpr command
      setExprArgs[0] = timeControl.GetFullName()+L".current";
      setExprArgs[1] = L"T";
      Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
   }
   // now update the args to use the timecontrol instead
   setExprArgs[1] = timeControl.GetFullName()+L".current * "+timeControl.GetFullName()+L".factor + "+timeControl.GetFullName()+L".offset";

   // store the time control in a value array
   CValueArray createItemArgs(5);
   createItemArgs[0] = timeControl.GetRef();
   createItemArgs[1] = importClusters;
   createItemArgs[2] = importNormals;
   createItemArgs[3] = importUVs;
   createItemArgs[4] = importVisibility;

   //// let's figure out which objects we have
   //std::vector<Alembic::Abc::IObject> objects;
   ////objects.push_back(archive->getTop());
   //size_t nbTransforms = 1;
   //{
	  // ESS_PROFILE_SCOPE("alembic_import_Execute traverse ABC Hierarchy");
	  // for(size_t i=0;i<objects.size();i++)
	  // {
		 // // first, let's recurse, do the transforms last
		 // for(size_t j=0;j<objects[i].getNumChildren();j++)
		 // {
			// if(!Alembic::AbcGeom::IXform::matches(objects[i].getChild(j).getMetaData()))
			//	objects.push_back(objects[i].getChild(j));
		 // }
		 // for(size_t j=0;j<objects[i].getNumChildren();j++)
		 // {
			// if(Alembic::AbcGeom::IXform::matches(objects[i].getChild(j).getMetaData())) 
			// {
			//	objects.push_back(objects[i].getChild(j));
			//	nbTransforms++;
			// }
		 // }
	  // }
   //}




   

   Alembic::AbcGeom::IObject root = archive->getTop();

   std::vector<std::string> nodesToImport;
   std::map<std::string, bool> map;
	int nNumNodes = prescanAlembicHierarchy(root, nodesToImport, map);


   ProgressBar prog;
   prog = Application().GetUIToolkit().GetProgressBar();
   prog.PutMinimum(0);
   prog.PutMaximum(nNumNodes);//(identifierMap.size() == 0 ? (LONG)objects.size() : (LONG)identifierMap.size());
   prog.PutValue(0);
   prog.PutCancelEnabled(true);
   prog.PutVisible(true);

   // clear the imported names!
   nameMapClear();
   CString transformCacheModelName;
   Model transformCacheModel;

   // clear all alembic user data
   alembic_UD::clearAll();

   std::list<stackElement> sceneStack;
	for(size_t j=0; j<root.getNumChildren(); j++)
	{
      sceneStack.push_back(stackElement(root.getChild(j), Application().GetActiveSceneRoot()));
	} 


   int intermittentUpdateInterval = std::max( (int)(nNumNodes / 100), (int)1 );
   int i = 0;
   while( !sceneStack.empty() )
   {
      stackElement sElement = sceneStack.back();
      Alembic::Abc::IObject iObj = sElement.iObj;
      CRef parentNode(sElement.parentNode);
      sceneStack.pop_back();

      if( i % intermittentUpdateInterval == 0 ) {
         prog.PutCaption(L"Importing "+CString(iObj.getFullName().c_str())+L" ...");
      }
      i++;

      ESS_LOG_WARNING("Importing "<<iObj.getFullName().c_str()<<" ...");

      bool bCreateNullNode = false;
      int nMergedGeomNodeIndex = -1;
		Alembic::AbcGeom::IObject mergedGeomChild;

      getMergeInfo(iObj, bCreateNullNode, nMergedGeomNodeIndex, mergedGeomChild);

      CRef newNode;
		if(bCreateNullNode){

         createTransform( iObj, parentNode, newNode, filename, attachToExisting, createItemArgs);
		}
		else{
			if(nMergedGeomNodeIndex != -1){//we are merging, so look at the child geometry node

				createShape( mergedGeomChild, parentNode, newNode, filename, attachToExisting, importStandins, importBboxes, true, createItemArgs);
			}
			else{ //geometry node(s) under a dummy node 

            //TODO: not sure if I handle the transforms correctly in this case
            return CStatus::Abort;
				//createShape( iObj, parentNode, newNode, filename, attachToExisting, importStandins, importBboxes, false, createItemArgs);
			}

		}
      
      //newNode will not be valid if we cannot attach children to it
      if(newNode.IsValid()){

         //push the children as the last step, since we need to who the parent is first (we may have merged)
	      for(size_t j=0; j<iObj.getNumChildren(); j++)
	      {
            if( NodeCategory::get(iObj.getChild(j)) == NodeCategory::UNSUPPORTED ) continue;// skip over unsupported types

            //I assume that geometry nodes are always leaf nodes. Thus, if we merged a geometry node will its parent transform, we don't
            //need to push it to the stack.
            //A geometry node can't be combined with its transform node, the transform node has other tranform nodes as children. These
            //nodes must be pushed.
            if( nMergedGeomNodeIndex != j )
            {
               sceneStack.push_back( stackElement(iObj.getChild(j), newNode) );
            }
	      }
      }
      else{
         ESS_LOG_WARNING("Warning: newNode CRef is not valid.");
         return CStatus::Abort;
      }

      if(prog.IsCancelPressed())
         break;
      prog.Increment();
   }

   prog.PutVisible(false);



   delete(archive);

   return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_MenuExport_Init,CRef&)
	Context ctxt( in_ctxt );
	Menu oMenu;
	oMenu = ctxt.GetSource();
	MenuItem oNewItem;
	oMenu.AddCommandItem(L"Alembic 1.0",L"alembic_export",oNewItem);
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_MenuImport_Init,CRef&)
	Context ctxt( in_ctxt );
	Menu oMenu;
	oMenu = ctxt.GetSource();
	MenuItem oNewItem;
	oMenu.AddCommandItem(L"Alembic 1.0",L"alembic_import",oNewItem);
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_MenuPathManager_Init,CRef&)
	Context ctxt( in_ctxt );
	Menu oMenu;
	oMenu = ctxt.GetSource();
	MenuItem oNewItem;
	oMenu.AddCommandItem(L"Alembic Path Manager",L"alembic_path_manager",oNewItem);
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_ProfileStats_Init,CRef&)
	Context ctxt( in_ctxt );
	Menu oMenu;
	oMenu = ctxt.GetSource();
	MenuItem oNewItem;
	oMenu.AddCommandItem(L"Alembic Profile Stats",L"alembic_profile_stats",oNewItem);
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_export_settings_Define,CRef&)
	Context ctxt( in_ctxt );
	CustomProperty oCustomProperty;
	Parameter oParam;
	oCustomProperty = ctxt.GetSource();

   // get the current frame in an out
   CValueArray cmdArgs(1);
   CValue cmdReturnVal;
   cmdArgs[0] = L"PlayControl.In";
   Application().ExecuteCommand(L"GetValue",cmdArgs,cmdReturnVal);
   oCustomProperty.AddParameter(L"frame_in",CValue::siInt4,siPersistable,L"",L"",floorf(float(cmdReturnVal)+0.5f),-1000000,1000000,1,100,oParam);
   cmdArgs[0] = L"PlayControl.Out";
   Application().ExecuteCommand(L"GetValue",cmdArgs,cmdReturnVal);
   oCustomProperty.AddParameter(L"frame_out",CValue::siInt4,siPersistable,L"",L"",floorf(float(cmdReturnVal)+0.5f),-1000000,1000000,1,100,oParam);
   oCustomProperty.AddParameter(L"frame_step",CValue::siInt4,siPersistable,L"",L"",1,-1000000,1000000,1,5,oParam);
   oCustomProperty.AddParameter(L"frame_substep",CValue::siInt4,siPersistable,L"",L"",1,-1000000,1000000,1,5,oParam);

	oCustomProperty.AddParameter(L"normals",CValue::siInt4,siPersistable,L"",L"",2,0,10,0,10,oParam);
   oCustomProperty.AddParameter(L"uvs",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"facesets",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"bindpose",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   //oCustomProperty.AddParameter(L"globalspace",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"dtopology",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"guidecurves",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"transformcache",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"transforms",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);

	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_export_settings_DefineLayout,CRef&)
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();

   oLayout.AddGroup(L"Animation");
   oLayout.AddItem(L"frame_in",L"In");
   oLayout.AddItem(L"frame_out",L"Out");
   oLayout.AddItem(L"frame_step",L"Frame-Steps");
   oLayout.AddItem(L"frame_substep",L"Sub-Steps");
   oLayout.EndGroup();

   CValueArray normalItems(6);
   oLayout.AddGroup(L"Geometry");
   normalItems[0] = L"Point Cache (No Surface)";
   normalItems[1] = (LONG) 0l;
   normalItems[2] = L"Just Surface (No Normals)";
   normalItems[3] = (LONG) 1l;
   normalItems[4] = L"Surface + Normals (For Interchange)";
   normalItems[5] = (LONG) 2l;
   oLayout.AddEnumControl(L"normals",normalItems,L"Mesh Topology");
   oLayout.AddItem(L"uvs",L"UVs");
   oLayout.AddItem(L"facesets",L"Clusters");
   oLayout.AddItem(L"bindpose",L"Envelope BindPose");
   oLayout.AddItem(L"dtopology",L"Dynamic Topology");
   oLayout.AddItem(L"guidecurves",L"Guide Curves");
   //oLayout.AddItem(L"globalspace",L"Use Global Space");
   oLayout.EndGroup();
   oLayout.AddItem(L"transformcache",L"Cache Transforms Only");
   
   CValueArray transformItems(6);
   transformItems[0] = L"Flatten Hierarchy";
   transformItems[1] = (LONG) 0;
   transformItems[2] = L"Full Hierarchy";
   transformItems[3] = (LONG) 1;
   transformItems[4] = L"Bake Into Geometry";
   transformItems[5] = (LONG) 2;
   oLayout.AddEnumControl(L"transforms", transformItems, L"Transforms");

	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_export_settings_PPGEvent,const CRef&)
	PPGEventContext ctxt( in_ctxt ) ;
	if ( ctxt.GetEventID() == PPGEventContext::siParameterChange )
	{
		Parameter param = ctxt.GetSource() ;	
		CString paramName = param.GetScriptName() ; 
      if(paramName.IsEqualNoCase(L"normals"))
      {
         bool enable = LONG(param.GetValue()) > 0;
         Property prop(param.GetParent());
         Parameter(prop.GetParameters().GetItem(L"uvs")).PutCapabilityFlag(siReadOnly,!enable);
         Parameter(prop.GetParameters().GetItem(L"facesets")).PutCapabilityFlag(siReadOnly,!enable);
         Parameter(prop.GetParameters().GetItem(L"bindpose")).PutCapabilityFlag(siReadOnly,!enable);
         Parameter(prop.GetParameters().GetItem(L"dtopology")).PutCapabilityFlag(siReadOnly,!enable);
      }
	}
   else if (ctxt.GetEventID() == PPGEventContext::siButtonClicked)
   {
      CString buttonName = ctxt.GetAttribute(L"Button");
   }

	return CStatus::OK ;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_settings_Define, CRef&)
	Context ctxt( in_ctxt );
	CustomProperty oCustomProperty;
	Parameter oParam;
	oCustomProperty = ctxt.GetSource();

   // get the current frame in an out
	oCustomProperty.AddParameter(L"normals",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"uvs",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"facesets",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"visibility",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   if(hasStandinSupport())
   {
      oCustomProperty.AddParameter(L"standins",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   }
   oCustomProperty.AddParameter(L"attach",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_settings_DefineLayout, CRef&)
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();

   oLayout.AddGroup(L"Geometry");
   oLayout.AddItem(L"normals",L"Normals");
   oLayout.AddItem(L"uvs",L"UVs");
   oLayout.AddItem(L"facesets",L"Clusters");

   CValueArray items(4);
   items[0] = L"Just Import Value";
   items[1] = (LONG) 0l;
   items[2] = L"Connected Operators";
   items[3] = (LONG) 1l;
   oLayout.AddEnumControl(L"visibility",items,L"Visibility");

   if(hasStandinSupport())
   {
      items.Resize(6);
      items[0] = L"No standins";
      items[1] = (LONG) 0l;
      items[2] = L"Import data + standins";
      items[3] = (LONG) 1l;
      items[4] = L"Standins as bboxes";
      items[5] = (LONG) 2l;
      oLayout.AddEnumControl(L"standins",items,L"Standins");
   }
   oLayout.AddItem(L"attach",L"Attach to existing objects");
   oLayout.EndGroup();

	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_timecontrol_Define, CRef&)
	Context ctxt( in_ctxt );
	CustomProperty oCustomProperty;
	Parameter oParam;
	oCustomProperty = ctxt.GetSource();

   // get the current frame in an out
	oCustomProperty.AddParameter(L"current",CValue::siFloat,siAnimatable | siPersistable,L"",L"",0,-100000,100000,-1,1,oParam);
	oCustomProperty.AddParameter(L"factor",CValue::siFloat,siAnimatable | siPersistable,L"",L"",1,-100000,100000,0,2,oParam);
	oCustomProperty.AddParameter(L"offset",CValue::siFloat,siAnimatable | siPersistable,L"",L"",0,-100000,100000,-5,5,oParam);
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_timecontrol_DefineLayout, CRef&)
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();
   oLayout.AddItem(L"current",L"Current Time");
   oLayout.AddItem(L"factor",L"Time Factor");
   oLayout.AddItem(L"offset",L"Time Offset");
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_standinop_Define, CRef&)
   Context ctxt( in_ctxt );
   CustomOperator oCustomOperator;

   Parameter oParam;
   CRef oPDef;

   Factory oFactory = Application().GetFactory();
   oCustomOperator = ctxt.GetSource();

   oPDef = oFactory.CreateParamDef(L"tokens",CValue::siString,siPersistable,L"tokens",L"tokens",L"",L"",L"",L"",L"");
   oCustomOperator.AddParameter(oPDef,oParam);
   oPDef = oFactory.CreateParamDef(L"time",CValue::siFloat,siPersistable | siAnimatable,L"time",L"time",0.0f,-100000.0f,100000.0f,0.0f,100.0f);
   oCustomOperator.AddParameter(oPDef,oParam);

   oCustomOperator.PutAlwaysEvaluate(false);
   oCustomOperator.PutDebug(0);

   return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_standinop_DefineLayout, CRef&)
   Context ctxt( in_ctxt );
   PPGLayout oLayout;
   PPGItem oItem;
   oLayout = ctxt.GetSource();
   oLayout.Clear();
   oLayout.AddItem(L"tokens",L"Tokens");
   oLayout.AddItem(L"time",L"Time");
   return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_standinop_Update, CRef&)

   // if we are not interactive, let's just return here
   // the property should have all of its values anyways
   if(!Application().IsInteractive())
      return CStatus::OK;

   OperatorContext ctxt( in_ctxt );
   CString tokens = ctxt.GetParameterValue(L"tokens");
   CStringArray paths(2);
   CStringArray identifiers(2);
   CString renderidentifier;
   CustomOperator op(ctxt.GetInputValue(0));
   CRef x3dRef;
   if(op.IsValid())
   {
      paths[0] = op.GetParameterValue(L"path");
      identifiers[0] = op.GetParameterValue(L"identifier");
      paths[1] = op.GetParameterValue(L"renderpath");
      identifiers[1] = op.GetParameterValue(L"renderidentifier");
      x3dRef = op.GetParent3DObject().GetRef();
   }
   else
   {
      ICENode node(ctxt.GetInputValue(0));
      paths[0] = node.GetParameterValue(L"path_string");
      identifiers[0] = node.GetParameterValue(L"identifier_string");
      paths[1] = node.GetParameterValue(L"renderpath_string");
      identifiers[1] = node.GetParameterValue(L"renderidentifier_string");
      CString nodeFullName = node.GetFullName();
      CStringArray nodeNameParts = nodeFullName.Split(L".");
      CRef modelRef;
      modelRef.Set(nodeNameParts[0]);
      Model model(modelRef);
      if(model.IsValid())
         x3dRef.Set(nodeNameParts[0]+L"."+nodeNameParts[1]);
      else
         x3dRef = modelRef;
   }

   // try to replace all tokens except for the environment token
   for(LONG i=0;i<paths.GetCount();i++)
   {
      // let's replace the [env name] token with a custom one
      // [alembicenv0], and then we can add these tokens ourselves
      CString result;
      CStringArray envVarNames;
      CStringArray envVarValues;
      while(paths[i].Length() > 0)
      {
         CString subString = paths[i].GetSubString(0,paths[i].FindString(L"[")+1);
         if(subString.IsEmpty())
         {
            result += paths[i];
            break;
         }
         result += subString.GetSubString(0,subString.Length()-1);
         paths[i] = paths[i].GetSubString(subString.Length(),10000);
         if(paths[i].GetSubString(0,4).IsEqualNoCase(L"env "))
         {
            subString = paths[i].GetSubString(0,paths[i].FindString(L"]"));
            if(subString.IsEmpty())
            {
               result += paths[i];
               break;
            }
            paths[i] = paths[i].GetSubString(subString.Length()+1,10000);
            CString envVarName = L"tempenvvar"+CString(envVarNames.GetCount());
            envVarNames.Add(envVarName);
            envVarValues.Add(L"{"+subString+L"}");
            result += L"["+envVarName+L"]";
         }
         else
         {
            // save other tokens
            subString = paths[i].GetSubString(0,paths[i].FindString(L"]"));
            paths[i] = paths[i].GetSubString(subString.Length()+1,10000);
            result += L"["+subString+L"]";
         }
      }
      paths[i] = XSI::CUtils::ResolveTokenString(result,XSI::CTime(),false,envVarNames,envVarValues);
   }

   float time = ctxt.GetParameterValue(L"time");

   CString data = tokens;
   CString tokensLower = tokens; tokensLower.Lower();
   tokensLower = L"&" + tokensLower;
   if(tokensLower.FindString(L"&path=") == -1)
      data += CString(data.IsEmpty() ? L"" : L"&") + L"path="+(paths[1].IsEmpty() ? paths[0] : paths[1]);
   if(tokensLower.FindString(L"&identifier=") == -1)
      data += CString(data.IsEmpty() ? L"" : L"&") + L"identifier="+(identifiers[1].IsEmpty() ? identifiers[0] : identifiers[1]);
   float globalTime = floorf(time * 1000.0f + 0.5f) / 1000.0f;
   if(tokensLower.FindString(L"&time=") == -1)
      data += CString(data.IsEmpty() ? L"" : L"&") + L"time="+CValue(globalTime).GetAsText();
   float currentTime = (float)(floor(CTime().GetTime(CTime::Seconds) * 1000.0 + 0.5) / 1000.0);
   if(tokensLower.FindString(L"&currtime=") == -1)
      data += CString(data.IsEmpty() ? L"" : L"&") + L"currtime="+CValue(currentTime).GetAsText();

   // now get the motion blur keys
   if(tokensLower.FindString(L"&mbkeys=") == -1)
   {
      CString mbKeysStr;
      CDoubleArray mbKeys;
      GetArnoldMotionBlurData(mbKeys,globalTime * (float)CTime().GetFrameRate());
      if(mbKeys.GetCount() > 0)
      {
         mbKeysStr = L"mbkeys="+CValue(floorf(float(mbKeys[0]) * 1000.0f + 0.5f) / (1000.0f * (float)CTime().GetFrameRate())).GetAsText();
         for(LONG i=1;i<mbKeys.GetCount();i++)
            mbKeysStr += L";"+CValue(floorf(float(mbKeys[i]) * 1000.0f + 0.5f) / (1000.0f * (float)CTime().GetFrameRate())).GetAsText();
      }
      if(!mbKeysStr.IsEmpty())
         data += CString(data.IsEmpty() ? L"" : L"&")+mbKeysStr;
   }

   // output the data to a custom property
   CustomProperty prop(ctxt.GetOutputTarget());
   prop.PutParameterValue(L"path",getDSOPath());
   prop.PutParameterValue(L"dsodata",data);
   prop.PutParameterValue(L"boundsType",(LONG)0l);
   //prop.PutParameterValue(L"deferredLoading",true);

   return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_profile_stats_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_profile_stats_Execute, CRef&)
    ESS_PROFILE_REPORT();
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_path_manager_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"model");
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_path_manager_Execute, CRef&)
    ESS_PROFILE_REPORT();

	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
   CString model = args[0];
   CRefArray allRefs;
   CString search;
   if(model.IsEmpty())
   {
      search = L"*.*.*.alembic_*,*.*.*.ABC_*";
      search += L",*.*.alembic_*,*.*.ABC_*";
	  search += L",*.*.cls.Texture_Coordinates_AUTO.*.alembic*";
   }
   else
      search = model+L".*.*.alembic_*,"+model+"L.*.*.ABC_*";

   CComAPIHandler collection;
   collection.CreateInstance(L"XSI.Collection");
   collection.PutProperty(L"Unique",true);
   CValue returnVal;
   collection.Call(L"SetAsText",returnVal,search);
   CRefArray refs;
   for(LONG i=0;i<(LONG)collection.GetProperty(L"Count");i++)
   {
      CValueArray apiArgs;
      apiArgs.Add(i);
      collection.Invoke( L"Item", CComAPIHandler::PropertyGet, returnVal, apiArgs );
      CRef ref = returnVal;
      if(!ref.IsValid())
         continue;
      ICETree tree(ref);
      if(tree.IsValid())
      {
         CRefArray compounds = tree.GetCompoundNodes();
         for(LONG j=0;j<compounds.GetCount();j++)
         {
            ICECompoundNode compound(compounds[j]);
            if(compound.GetFullName() == tree.GetFullName())
               continue;
            if(compound.GetName().GetSubString(0,8).IsEqualNoCase(L"abc load"))
               refs.Add(compound.GetRef());
         }
         continue;
      }
      CustomOperator op(ref);
      if(op.IsValid())
      {
         refs.Add(ref);
         continue;
      }
   }

   stringMap pathMap;
   stringMap identifierMap;
   stringMap * maps[4];
   maps[0] = &pathMap;
   maps[1] = &pathMap;
   maps[2] = &identifierMap;
   maps[3] = &identifierMap;
   CStringArray paramName;
   paramName.Add(L"path");
   paramName.Add(L"renderpath");
   paramName.Add(L"identifier");
   paramName.Add(L"renderidentifier");

   for(LONG i=0;i<refs.GetCount();i++)
   {
      std::string values[4];
      ICECompoundNode tree(refs[i]);
      if(tree.IsValid())
      {
         for(LONG j=0;j<paramName.GetCount();j++)
         {
            ICENodeInputPort port = tree.GetInputPorts().GetItem(paramName[j]);
            Parameter param = port.GetParameters()[0];
            values[j] = CString(param.GetValue()).GetAsciiString();
         }
      }
      else
      {
         CustomOperator op(refs[i]);
         if(op.IsValid())
         {
            for(LONG j=0;j<paramName.GetCount();j++)
               values[j] = CString(op.GetParameterValue(paramName[j])).GetAsciiString();
         }
      }

      for(LONG j=0;j<paramName.GetCount();j++)
         if(maps[j]->find(values[j]) == maps[j]->end() && !values[j].empty())
            maps[j]->insert(stringPair(values[j],values[j]));
   }

   if(pathMap.size() == 0 && identifierMap.size() == 0)
   {
      Application().LogMessage(L"[ExocortexAlembic] No alembic operators / icetrees found!",siWarningMsg);
      return CStatus::OK;
   }

   // awesome - construct the custom property
   CustomProperty prop = (CustomProperty) Application().GetActiveSceneRoot().AddProperty(L"CustomProperty");
   prop.PutName(L"options");
   PPGLayout layout = prop.GetPPGLayout();
   layout.Clear();

   // add the search and replace stuff
	Parameter oParam;
   LONG pathCount = 0;
   LONG identifierCount = 0;
   if(pathMap.size() > 0)
   {
      prop.AddParameter(L"path_search",CValue::siString,siPersistable,L"",L"",L"",L"",L"",L"",L"",oParam);
      prop.AddParameter(L"path_replace",CValue::siString,siPersistable,L"",L"",L"",L"",L"",L"",L"",oParam);
      layout.AddTab(L"Paths");
      layout.AddGroup(L"Search and Replace");
      layout.AddItem(L"path_search").PutAttribute(siUINoLabel,true);
      layout.AddItem(L"path_replace").PutAttribute(siUINoLabel,true);
      layout.AddButton(L"path_button0",L"Replace All");
      layout.EndGroup();

      for(stringMapIt it = pathMap.begin(); it != pathMap.end(); it++)
      {
         prop.AddParameter(L"_path_"+CString(pathCount),CValue::siString,siPersistable,L"",L"",it->second.c_str(),L"",L"",L"",L"",oParam);
         layout.AddItem(L"_path_"+CString(pathCount)).PutAttribute(siUINoLabel,true);
         pathCount++;
      }
   }
   if(identifierMap.size() >  0)
   {
      prop.AddParameter(L"identifier_search",CValue::siString,siPersistable,L"",L"",L"",L"",L"",L"",L"",oParam);
      prop.AddParameter(L"identifier_replace",CValue::siString,siPersistable,L"",L"",L"",L"",L"",L"",L"",oParam);
      layout.AddTab(L"Identifiers");
      layout.AddGroup(L"Search and Replace");
      layout.AddItem(L"identifier_search").PutAttribute(siUINoLabel,true);
      layout.AddItem(L"identifier_replace").PutAttribute(siUINoLabel,true);
      layout.AddButton(L"identifier_button0",L"Replace All");
      layout.EndGroup();

      for(stringMapIt it = identifierMap.begin(); it != identifierMap.end(); it++)
      {
         prop.AddParameter(L"_identifier_"+CString(identifierCount),CValue::siString,siPersistable,L"",L"",it->second.c_str(),L"",L"",L"",L"",oParam);
         layout.AddItem(L"_identifier_"+CString(identifierCount)).PutAttribute(siUINoLabel,true);
         identifierCount++;
      }
   }

   // construct the logic
   layout.PutLanguage(L"JScript");
   CString logic;
   logic += L"function path_button0_OnClicked() {\n";
   logic += L"  var prop = PPG.Inspected(0);\n";
   logic += L"  var search = prop.parameters('path_search').value;\n";
   logic += L"  var replace = prop.parameters('path_replace').value;\n";
   logic += L"  if(!search){\n";
   logic += L"    LogMessage('[ExocortexAlembic] No search string specified!',siWarningMsg);\n";
   logic += L"    return;\n";
   logic += L"  }\n";
   logic += L"  for(var i=0;i<prop.parameters.count;i++){\n";
   logic += L"    var name = prop.parameters(i).scriptname;\n";
   logic += L"    if(name.substr(0,6) != '_path_')continue;\n";
   logic += L"    var value = prop.parameters(i).value;\n";
   logic += L"    value = value.replace(search,replace);\n";
   logic += L"    prop.parameters(i).value = value;\n";
   logic += L"  }\n";
   logic += L"}\n";
   logic += L"function identifier_button0_OnClicked() {\n";
   logic += L"  var prop = PPG.Inspected(0);\n";
   logic += L"  var search = prop.parameters('identifier_search').value;\n";
   logic += L"  var replace = prop.parameters('identifier_replace').value;\n";
   logic += L"  if(!search){\n";
   logic += L"    LogMessage('[ExocortexAlembic] No search string specified!',siWarningMsg);\n";
   logic += L"    return;\n";
   logic += L"  }\n";
   logic += L"  for(var i=0;i<prop.parameters.count;i++){\n";
   logic += L"    var name = prop.parameters(i).scriptname;\n";
   logic += L"    if(name.substr(0,12) != '_identifier_')continue;\n";
   logic += L"    var value = prop.parameters(i).value;\n";
   logic += L"    value = value.replace(search,replace);\n";
   logic += L"    prop.parameters(i).value = value;\n";
   logic += L"  }\n";
   logic += L"}\n";
   layout.PutLogic(logic);

   CValueArray inspectArgs(5);
   CValue inspectResult;
   inspectArgs[0] = prop.GetFullName();
   inspectArgs[1] = L"";
   inspectArgs[2] = L"Path Manager";
   inspectArgs[3] = siModal;
   inspectArgs[4] = false;
   Application().ExecuteCommand(L"InspectObj",inspectArgs,inspectResult);
   
   // prepare for deletion
   if(!inspectResult)
   {
      // read all of the values
      pathCount = identifierCount = 0;
      for(stringMapIt it = pathMap.begin(); it != pathMap.end(); it++)
      {
         CString value = prop.GetParameterValue(L"_path_"+CString(pathCount++));
         it->second = value.GetAsciiString();
      }
      for(stringMapIt it = identifierMap.begin(); it != identifierMap.end(); it++)
      {
         CString value = prop.GetParameterValue(L"_identifier_"+CString(identifierCount++));
         it->second = value.GetAsciiString();
      }

      // loop over all refs and replace
      for(LONG i=0;i<refs.GetCount();i++)
      {
         ICECompoundNode tree(refs[i]);
         if(tree.IsValid())
         {
            for(LONG j=0;j<paramName.GetCount();j++)
            {
               ICENodeInputPort port = tree.GetInputPorts().GetItem(paramName[j]);
               Parameter param = port.GetParameters()[0];
               CString value = CString(param.GetValue()).GetAsciiString();
               stringMapIt it = maps[j]->find(value.GetAsciiString());
               if(it != maps[j]->end())
               {
                  if(CString(it->second.c_str()) != value)
                  {
                     if(j<2)
                        addRefArchive(CString(it->second.c_str()));
                     param.PutValue(CString(it->second.c_str()));
                  }
               }
            }
            continue;
         }
         CustomOperator op(refs[i]);
         if(op.IsValid())
         {
            for(LONG j=0;j<paramName.GetCount();j++)
            {
               CString value = op.GetParameterValue(paramName[j]);
               stringMapIt it = maps[j]->find(value.GetAsciiString());
               if(it != maps[j]->end())
               {
                  if(CString(it->second.c_str()) != value)
                  {
                     if(j<2)
                        addRefArchive(CString(it->second.c_str()));
                     op.PutParameterValue(paramName[j],CString(it->second.c_str()));
                  }
               }
            }
            continue;
         }
      }
   }

   // if we still have the property, we need to delete it!
   if(prop.IsValid())
   {
      CValue returnVal;
      CValueArray cmdArgs;
      cmdArgs.Add(prop.GetFullName());
      Application().ExecuteCommand(L"DeleteObj",cmdArgs,returnVal);
   }

   return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_OnCloseScene_OnEvent,CRef&)
   deleteAllArchives();
	return CStatus::OK;
ESS_CALLBACK_END
