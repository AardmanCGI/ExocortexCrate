

global proc exocortexAlembicExport(string $filename,         string $exported_objects[], int $exportInframe,
                                   int $exportOutframe,      int $exportStepframe,       int $exportSubstepframe,
                                   int $exportTopology,      int $exportUVs,             int $exportFaceSets,
                                   int $exportDynamicTopo,   int $exportGlobalSpace,     int $exportWithoutHierarchy,
                                   int $exportTransformCache)
{
  ExocortexAlembic_profileBegin -f MEL_exocortexAlembicExport;
  // construct the job string
  string $job = ("in="+$exportInframe+";out="+$exportOutframe+";step="+$exportStepframe+";substep="+$exportSubstepframe+";filename="+$filename+";objects=");
  for($i=0;$i<size($exported_objects);$i++)
  {
    if($i>0)
      $job += ",";
    $job += $exported_objects[$i];
  }
  print $exportTopology;
  if($exportTopology == 1)    
  {
    $job += ";purepointcache=1;dynamictopology=0;normals=0;uvs=0;facesets=0";
  }
  else if($exportTopology == 2)    
  {
    $job += ";purepointcache=0;normals=0;dynamictopology=0";
    $job += ";uvs="+$exportUVs;
    $job += ";facesets="+$exportFaceSets;
  }
  else if($exportTopology == 3)    
  {
    $job += ";purepointcache=0;normals=1";
    $job += ";uvs="+$exportUVs;
    $job += ";facesets="+$exportFaceSets;
    $job += ";dynamictopology="+$exportDynamicTopo;
  }
  $job += ";globalspace="+$exportGlobalSpace;
  $job += ";withouthierarchy="+$exportWithoutHierarchy;
  $job += ";transformcache="+$exportTransformCache;
  print $job;
  ExocortexAlembic_export -j $job;
  ExocortexAlembic_profileEnd -f MEL_exocortexAlembicExport;
}

global proc exocortexAlembicImport(string $filename, int $importNormals, int $importUvs, int $importFaceSets, string $importVisibility, int $importAttach)
{
  ExocortexAlembic_profileReset;
  ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport;

  // query the content of the file
  ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_Init;

  string $infos[] = `ExocortexAlembic_getInfo -f $filename`;
  string $identifiers[];
  string $types[];
  int $nbTransforms = 0;
  string $names[];
  string $nodes[];
  string $datas[];
  int $nbSamples[];
  int $parentID[];
  string $childIDs[];
  for($i=0; $i<size($infos); $i=$i+1)
  {
    // tokenize the basic arguments
    string $tokens[];
    tokenize $infos[$i] "|" $tokens;
    if(size($tokens) < 4)
    {
      print ("Skipping invalid info "+$infos[$i]+".");
      continue;
    }

    // extract the information
    string $identifier = $tokens[0];
    string $type = $tokens[1];
    if($type == "Xform")
      $nbTransforms = $nbTransforms + 1;
    string $name = $tokens[2];
    string $node = `ExocortexAlembic_getNodeFromIdentifier -i $identifier`;

    // push the identifier to our map      
    $identifiers[size($identifiers)] = $identifier;
    $types[size($types)] = $type;
    $names[size($names)] = `ExocortexAlembic_createValidName -i $tokens[2]`;
    $nodes[size($nodes)] = $node;
    $nbSamples[size($nbSamples)] = $tokens[3];
    $parentID[size($parentID)] = $tokens[4];
    $childIDs[size($childIDs)] = $tokens[5];
    
    // parse the forth token
    string $data = "";
    if(size($tokens)>6)
      $data = $tokens[6];
    $datas[size($datas)] = $data;
  }

  ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_Init;

  // let's create the time node and file node
  $timeControl = exocortexCreateOrReuseNode("ExocortexAlembicTimeControl","ExocortexAlembicTimeControl",$importAttach,0,0);
  exocortexConnectIfUnconnected("time1.outTime",($timeControl+".inTime"));
  $fileNode = exocortexCreateOrReuseNode("ExocortexAlembicFile","ExocortexAlembicFile",0,0,0);
  setAttr -type "string" ($fileNode+".fileName ") $filename;
  
  print "parsing file...";
  
  // now let's create all items
  string $objects[];
  for($i=0;$i<size($identifiers);$i=$i+1)
    $objects[$i] = "";
  for($i=(size($identifiers)-1);$i>=0;$i=$i-1)
  {
    if ($identifiers[$i] == "")
      continue;
    string $parts[];
    tokenize $identifiers[$i] "/" $parts;
    string $name = $names[$i];
    string $reader;
    string $topoReader;
    string $shape;
    
    // parse additional data options
    int $purepointcache = 0;
    int $dynamictopology = 0;
    int $hair = 0;
    string $data[];
    tokenize $datas[$i] ";" $data;
    for($j=0;$j<size($data);$j=$j+1)
    {
      if($data[$j]=="purepointcache=1")
        $purepointcache = 1;
      else if($data[$j]=="dynamictopology=1")
        $dynamictopology = 1;
      else if($data[$j]=="hair=1")
        $hair = 1;
    }

    if($types[$i] == "PolyMesh")
    {
      ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_PolyMesh;
      $shape = exocortexCreateOrReuseNode($name,"mesh",$importAttach,0,$purepointcache);
      if($shape == "")
      {
        error ("Mesh '"+$name+"' not found for purepointcache alembic import.");
        return;
      }
      sets -e -forceElement initialShadingGroup $shape;
      if($dynamictopology == 1)
        $reader = exocortexCreateOrReuseNode($name+".inMesh","ExocortexAlembicPolyMesh",$importAttach,1,1);
      else
        $reader = exocortexCreateOrReuseNode($name+".inMesh","ExocortexAlembicPolyMeshDeform",$importAttach,1,1);
      if($reader == "")
      {
        if($purepointcache == 0)
        {
          $topoReader = exocortexCreateOrReuseNode("ExocortexAlembicPolyMesh","ExocortexAlembicPolyMesh",0,0,0);
          exocortexConnectIfUnconnected(($topoReader+".outMesh"), ($shape+".inMesh"));
          exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($topoReader+".fileName"));
          setAttr -type "string" ($topoReader+".identifier") $identifiers[$i];
          setAttr ($topoReader+".normals") $importNormals;
          setAttr ($topoReader+".uvs") $importUvs;
          if($importFaceSets)
            ExocortexAlembic_createFaceSets -f $filename -i $identifiers[$i] -o $shape;
          if($dynamictopology == 1)
            $reader = $topoReader;
        }
        if($reader == "")
        {
          string $readers[] = `deformer -type "ExocortexAlembicPolyMeshDeform" $shape`;
          $reader = $readers[0];
        }
      }
      ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_PolyMesh;
    }
    else if($types[$i] == "SubD")
    {
      ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_SubD;
      $shape = exocortexCreateOrReuseNode($name,"subdiv",$importAttach,0,$purepointcache);
      if($shape == "")
      {
        error ("Subdiv '"+$name+"' not found for purepointcache alembic import.");
        return;
      }
      sets -e -forceElement initialShadingGroup $shape;
      if($dynamictopology == 1)
        $reader = exocortexCreateOrReuseNode($name+".create","ExocortexAlembicSubD",$importAttach,1,1);
      else
        $reader = exocortexCreateOrReuseNode($name+".create","ExocortexAlembicSubDDeform",$importAttach,1,1);
      if($reader == "")
      {
        if($purepointcache == 0)
        {
          $topoReader = exocortexCreateOrReuseNode("ExocortexAlembicSubD","ExocortexAlembicSubD",0,0,0);
          exocortexConnectIfUnconnected(($topoReader+".outSubdiv"), ($shape+".create"));
          exocortexConnectIfUnconnected(($topoReader+".dispResolution"), ($shape+".dispResolution"));
          exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($topoReader+".fileName"));
          setAttr -type "string" ($topoReader+".identifier") $identifiers[$i];
          setAttr ($topoReader+".uvs") $importUvs;
          if($importFaceSets)
            ExocortexAlembic_createFaceSets -f $filename -i $identifiers[$i] -o $shape;
          if($dynamictopology == 1)
            $reader = $topoReader;
        }
        if($reader == "")
        {
          string $readers[] = `deformer -type "ExocortexAlembicSubDDeform" $shape`;
          $reader = $readers[0];
        }
      }
      ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_SubD;
    }
    else if($types[$i] == "Curves")
    {
      ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_Curves;
      if($hair == 0)
      {
        $shape = exocortexCreateOrReuseNode($name,"nurbsCurve",$importAttach,0,0);
        $reader = exocortexCreateOrReuseNode($name+".create","ExocortexAlembicCurvesDeform",$importAttach,1,1);
        if($reader == "")
        {
          $topoReader = exocortexCreateOrReuseNode("ExocortexAlembicCurves","ExocortexAlembicCurves",0,0,0);
          exocortexConnectIfUnconnected(($topoReader+".outCurve"), ($shape+".create"));
          exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($topoReader+".fileName"));
          setAttr -type "string" ($topoReader+".identifier") $identifiers[$i];
          string $readers[] = `deformer -type "ExocortexAlembicCurvesDeform" $shape`;
          $reader = $readers[0];
        }
      }
      else
      {
        $shape = exocortexCreateOrReuseNode($name,"ExocortexAlembicCurvesLocator",$importAttach,0,0);
        $reader = $shape;
      }
      ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_Curves;
    }
    else if($types[$i] == "Points")
    {
      ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_Points;
      $shape = exocortexCreateOrReuseNode($name,"particle",$importAttach,0,0);
      $reader = exocortexCreateOrReuseNode($shape+".newParticles[0]","ExocortexAlembicPoints",$importAttach,1,1);
      if($reader == "")
      {
        $reader = exocortexCreateOrReuseNode("ExocortexAlembicPoints","ExocortexAlembicPoints",$importAttach,0,0);
        addAttr -ln "rgbPP" -dt vectorArray $shape;
        addAttr -ln "opacityPP" -dt doubleArray $shape;
        addAttr -ln "agePP" -dt doubleArray $shape;
        addAttr -ln "shapeInstanceIdPP" -dt doubleArray $shape;
        addAttr -ln "orientationPP" -dt vectorArray $shape;
      }
      exocortexConnectIfUnconnected(($reader+".output[0]"), ($shape+".newParticles[0]"));
      exocortexConnectIfUnconnected(($timeControl+".outTime"), ($shape+".currentTime"));
      setAttr ($shape+".conserve") 0;
      ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_Points;
    }
    else if($types[$i] == "Camera")
    {
      ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_Camera;
      $shape = exocortexCreateOrReuseNode($name,"camera",$importAttach,0,0);
      $reader = exocortexCreateOrReuseNode($shape+".focalLength","ExocortexAlembicCamera",$importAttach,1,0);
      exocortexConnectIfUnconnected(($reader+".focalLength"), ($shape+".focalLength"));
      exocortexConnectIfUnconnected(($reader+".focusDistance"), ($shape+".focusDistance"));
      exocortexConnectIfUnconnected(($reader+".lensSqueezeRatio"), ($shape+".lensSqueezeRatio"));
      exocortexConnectIfUnconnected(($reader+".horizontalFilmAperture"), ($shape+".horizontalFilmAperture"));
      exocortexConnectIfUnconnected(($reader+".verticalFilmAperture"), ($shape+".verticalFilmAperture"));
      exocortexConnectIfUnconnected(($reader+".horizontalFilmOffset"), ($shape+".horizontalFilmOffset"));
      exocortexConnectIfUnconnected(($reader+".verticalFilmOffset"), ($shape+".verticalFilmOffset"));
      //exocortexConnectIfUnconnected(($reader+".nearClippingPlane"), ($shape+".nearClippingPlane"));
      //exocortexConnectIfUnconnected(($reader+".farClippingPlane"), ($shape+".farClippingPlane"));
      exocortexConnectIfUnconnected(($reader+".fStop"), ($shape+".fStop"));
      exocortexConnectIfUnconnected(($reader+".shutterAngle"), ($shape+".shutterAngle"));
      ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_Camera;
    }
    else if($types[$i] == "Xform")
    {
      ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_Xform;
      // if we have only transforms in the alembic file, this is a transform cache!
      if($nbTransforms == size($types))
      {
        string $locator = exocortexCreateOrReuseNode(($name+"Shape"),"locator",$importAttach,0,0);
        $xform = `listRelatives -p $locator`;
        $shape = $xform[0];
        $reader = exocortexCreateOrReuseNode($shape+"_translate","ExocortexAlembicXform",$importAttach,1,0);
        exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
        exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
        exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));
      }
      else
      {
        // let's look for the next element in the list
        // and access its children
        $reader = "";
        string $ids[];
        tokenize $childIDs[$i] "." $ids;
        int $cID = $ids[0];
        if ($cID > 0)
        {
          $shape = $objects[$cID-1];
          $xform = `listRelatives -p $shape`;
          if ( $name != "front" && $name != "top" && $name != "side" && $name != "persp" )
          {
            $shape = `rename -ignoreShape $xform[0] $name`;
            $reader = exocortexCreateOrReuseNode($shape+"_translate","ExocortexAlembicXform",$importAttach,1,0);
            exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
            exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
            exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));
          }
        }
      }
      if($reader == "")
        continue;
      ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_Xform;
    }
    else if($types[$i] == "Group")
    {
      ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_Group;
      // find all xforms below this
      if($nbTransforms == size($types))
      {
        string $locator = exocortexCreateOrReuseNode(($name+"Shape"),"locator",$importAttach,0,0);
        $xform = `listRelatives -p $locator`;
        $shape = $xform[0];
        $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
      }
      else
      {
        $shape = exocortexCreateOrReuseNode($name,"transform",$importAttach,0,0);
        $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
      }
      exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
      exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
      exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));

      ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_D;   
      string $ids[];
      tokenize $childIDs[$i] "." $ids;
      for ($j = 0; $j < size($ids); $j = $j + 1)
      {
        int $cID = $ids[$j];
        $cID = $cID - 1;
        if ($objects[$cID] == "" || $objects[$cID] == $shape)
          continue;
        if ($types[$cID] == "Xform" || $types[$cID] == "Group")
          parent $objects[$cID] $shape;
        else
          parent -s $objects[$cID] $shape;
      }
      ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_Group;
    }
    else if ($types[$i] == "")
    {
      continue;
    }
    else
    {
      print("Invalid object type "+$types[$i]+"\n");
      continue;
    }

    ExocortexAlembic_profileBegin -f MEL_exocortexAlembicImport_FinalizeObject;
    // connect the standard ports
    if($nbSamples[$i] > 1)
      exocortexConnectIfUnconnected(($timeControl+".outTime"), ($reader+".inTime"));
    exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($reader+".fileName"));
    setAttr -type "string" ($reader+".identifier") $identifiers[$i];
    $objects[$i] = $shape;
    ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport_FinalizeObject;
    
    // setup metadata if we have it
    ExocortexAlembic_createMetaData -f $filename -i $identifiers[$i] -o $shape;
  }

  ExocortexAlembic_postImportPoints;
  ExocortexAlembic_profileEnd -f MEL_exocortexAlembicImport;
}

global proc __exocortexAlembicAssignMaterialFromFaceSet(string $shape, int $faceIDs[], string $materialNode)
{
  // Create a new set for this shader
  string $sSet = `sets -r true -nss true -em -n ($materialNode+"Set")`;
  connectAttr -f ($materialNode + ".outColor") ($sSet + ".surfaceShader");

  // Add each face to the set
  for ($faceID in $faceIDs)
    sets -fe $sSet ($shape+".f["+$faceID+"]");
}

global proc exocortexAlembicAssignMaterial(string $shape, string $faceSetAttribute, string $materialNode)
{
  int $faceSet[] = `getAttr ($shape+"."+$faceSetAttribute)`;
  __exocortexAlembicAssignMaterialFromFaceSet($shape, $faceSet, $materialNode);
}

