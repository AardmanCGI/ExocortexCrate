

global proc exocortexAlembicExport(string $filename,         string $exported_objects[], int $exportInframe,
                                   int $exportOutframe,      int $exportStepframe,       int $exportSubstepframe,
                                   int $exportTopology,      int $exportUVs,             int $exportFaceSets,
                                   int $exportDynamicTopo,   int $exportGlobalSpace,     int $exportWithoutHierarchy,
                                   int $exportTransformCache)
{
  // construct the job string
  string $job = ("in="+$exportInframe+";out="+$exportOutframe+";step="+$exportStepframe+";substep="+$exportSubstepframe+";filename="+$filename+";objects=");
  for($i=0;$i<size($exported_objects);$i++)
  {
    if($i>0)
      $job += ",";
    $job += $exported_objects[$i];
  }
  print $exportTopology;
  if($exportTopology == 1)    
  {
    $job += ";purepointcache=1;dynamictopology=0;normals=0;uvs=0;facesets=0";
  }
  else if($exportTopology == 2)    
  {
    $job += ";purepointcache=0;normals=0;dynamictopology=0";
    $job += ";uvs="+$exportUVs;
    $job += ";facesets="+$exportFaceSets;
  }
  else if($exportTopology == 3)    
  {
    $job += ";purepointcache=0;normals=1";
    $job += ";uvs="+$exportUVs;
    $job += ";facesets="+$exportFaceSets;
    $job += ";dynamictopology="+$exportDynamicTopo;
  }
  $job += ";globalspace="+$exportGlobalSpace;
  $job += ";withouthierarchy="+$exportWithoutHierarchy;
  $job += ";transformcache="+$exportTransformCache;
  print $job;
  ExocortexAlembic_export -j $job;
}

global proc exocortexAlembicImport(string $filename, int $importNormals, int $importUvs, int $importFaceSets, string $importVisibility, int $importAttach)
{
  // query the content of the file
  string $infos[] = `ExocortexAlembic_getInfo -f $filename`;
  string $identifiers[];
  string $types[];
  int $nbTransforms = 0;
  string $names[];
  string $nodes[];
  string $datas[];
  int $nbSamples[];
  for($i=0; $i<size($infos); $i=$i+1)
  {
    // tokenize the basic arguments
    string $tokens[];
    tokenize $infos[$i] "|" $tokens;
    if(size($tokens) < 4)
    {
      print ("Skipping invalid info "+$infos[$i]+".");
      continue;
    }

    // extract the information
    string $identifier = $tokens[0];
    string $type = $tokens[1];
    if($type == "Xform")
      $nbTransforms = $nbTransforms + 1;
    string $name = $tokens[2];
    string $node = `ExocortexAlembic_getNodeFromIdentifier -i $identifier`;
    
    // try to find the identifier in the map
    int $skip = 0;
    for($j=0;$j<size($identifiers);$j=$j+1)
    {
      if($identifiers[$j] == $identifier)
      {
        print("Skipping duplicate identifier "+$identifier+".");
        $skip = 1;
        break;
      }
    }
    if($skip)
      break;

    // push the identifier to our map      
    $identifiers[size($identifiers)] = $identifier;
    $types[size($types)] = $type;
    $names[size($names)] = $tokens[2];
    $nodes[size($nodes)] = $node;
    $nbSamples[size($nbSamples)] = $tokens[3];
    
    // parse the forth token
    string $data = "";
    if(size($tokens)>4)
      $data = $tokens[4];
    $datas[size($datas)] = $data;
  }
  
  // now we need to determine the group types
  // group are alembic are xforms which have xforms
  // below them. for that we can loop on all identifiers
  // and find any identifier below it of type xform
  for($i=0; $i<size($identifiers); $i=$i+1)
  {
    if($types[$i] != "Xform")
      continue;
    for($j=$i+1;$j<size($identifiers); $j=$j+1)
    {
      if($types[$j] != "Xform")
        continue;
      if(size($identifiers[$i]) >= size($identifiers[$j]))
        continue;
      string $substring = `substring $identifiers[$j] 1 (size($identifiers[$i])+1)`;
      if($substring == ($identifiers[$i]+"/"))
      {
        $types[$i] = "Group";
        break;
      }
    }
  }

  // let's create the time node and file node
  $timeControl = exocortexCreateOrReuseNode("ExocortexAlembicTimeControl","ExocortexAlembicTimeControl",$importAttach,0,0);
  exocortexConnectIfUnconnected("time1.outTime",($timeControl+".inTime"));
  $fileNode = exocortexCreateOrReuseNode("ExocortexAlembicFile","ExocortexAlembicFile",0,0,0);
  setAttr -type "string" ($fileNode+".fileName ") $filename;
  
  print "parsing file...";
  
  // now let's create all items
  string $objects[];
  for($i=0;$i<size($identifiers);$i=$i+1)
    $objects[$i] = "";
  for($i=(size($identifiers)-1);$i>=0;$i=$i-1)
  {
    string $parts[];
    tokenize $identifiers[$i] "/" $parts;
    string $name = $names[$i];
    string $reader;
    string $topoReader;
    string $shape;
    
    // parse additional data options
    int $purepointcache = 0;
    int $dynamictopology = 0;
    int $hair = 0;
    string $data[];
    tokenize $datas[$i] ";" $data;
    for($j=0;$j<size($data);$j=$j+1)
    {
      if($data[$j]=="purepointcache=1")
        $purepointcache = 1;
      else if($data[$j]=="dynamictopology=1")
        $dynamictopology = 1;
      else if($data[$j]=="hair=1")
        $hair = 1;
    }

    if($types[$i] == "PolyMesh")
    {
      $shape = exocortexCreateOrReuseNode($name,"mesh",$importAttach,0,$purepointcache);
      if($shape == "")
      {
        error ("Mesh '"+$name+"' not found for purepointcache alembic import.");
        return;
      }
      if($dynamictopology == 1)
        $reader = exocortexCreateOrReuseNode($name+".inMesh","ExocortexAlembicPolyMesh",$importAttach,1,1);
      else
        $reader = exocortexCreateOrReuseNode($name+".inMesh","ExocortexAlembicPolyMeshDeform",$importAttach,1,1);
      if($reader == "")
      {
        if($purepointcache == 0)
        {
          $topoReader = exocortexCreateOrReuseNode("ExocortexAlembicPolyMesh","ExocortexAlembicPolyMesh",0,0,0);
          exocortexConnectIfUnconnected(($topoReader+".outMesh"), ($shape+".inMesh"));
          exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($topoReader+".fileName"));
          setAttr -type "string" ($topoReader+".identifier") $identifiers[$i];
          setAttr ($topoReader+".normals") $importNormals;
          setAttr ($topoReader+".uvs") $importUvs;
          if($importFaceSets)
            ExocortexAlembic_createFaceSets -f $filename -i $identifiers[$i] -o $shape;
          if($dynamictopology == 1)
            $reader = $topoReader;
        }
        if($reader == "")
        {
          string $readers[] = `deformer -type "ExocortexAlembicPolyMeshDeform" $shape`;
          $reader = $readers[0];
        }
      }
    }
    else if($types[$i] == "SubD")
    {
      $shape = exocortexCreateOrReuseNode($name,"subdiv",$importAttach,0,$purepointcache);
      if($shape == "")
      {
        error ("Subdiv '"+$name+"' not found for purepointcache alembic import.");
        return;
      }
      if($dynamictopology == 1)
        $reader = exocortexCreateOrReuseNode($name+".create","ExocortexAlembicSubD",$importAttach,1,1);
      else
        $reader = exocortexCreateOrReuseNode($name+".create","ExocortexAlembicSubDDeform",$importAttach,1,1);
      if($reader == "")
      {
        if($purepointcache == 0)
        {
          $topoReader = exocortexCreateOrReuseNode("ExocortexAlembicSubD","ExocortexAlembicSubD",0,0,0);
          exocortexConnectIfUnconnected(($topoReader+".outSubdiv"), ($shape+".create"));
          exocortexConnectIfUnconnected(($topoReader+".dispResolution"), ($shape+".dispResolution"));
          exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($topoReader+".fileName"));
          setAttr -type "string" ($topoReader+".identifier") $identifiers[$i];
          setAttr ($topoReader+".uvs") $importUvs;
          if($importFaceSets)
            ExocortexAlembic_createFaceSets -f $filename -i $identifiers[$i] -o $shape;
          if($dynamictopology == 1)
            $reader = $topoReader;
        }
        if($reader == "")
        {
          string $readers[] = `deformer -type "ExocortexAlembicSubDDeform" $shape`;
          $reader = $readers[0];
        }
      }
    }
    else if($types[$i] == "Curves")
    {
      if($hair == 0)
      {
        $shape = exocortexCreateOrReuseNode($name,"nurbsCurve",$importAttach,0,0);
        $reader = exocortexCreateOrReuseNode($name+".create","ExocortexAlembicCurvesDeform",$importAttach,1,1);
        if($reader == "")
        {
          $topoReader = exocortexCreateOrReuseNode("ExocortexAlembicCurves","ExocortexAlembicCurves",0,0,0);
          exocortexConnectIfUnconnected(($topoReader+".outCurve"), ($shape+".create"));
          exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($topoReader+".fileName"));
          setAttr -type "string" ($topoReader+".identifier") $identifiers[$i];
          string $readers[] = `deformer -type "ExocortexAlembicCurvesDeform" $shape`;
          $reader = $readers[0];
        }
      }
      else
      {
        $shape = exocortexCreateOrReuseNode($name,"ExocortexAlembicCurvesLocator",$importAttach,0,0);
        $reader = $shape;
      }
    }
    else if($types[$i] == "Points")
    {
      $shape = exocortexCreateOrReuseNode($name,"particle",$importAttach,0,0);
      $reader = exocortexCreateOrReuseNode($shape+".newParticles[0]","ExocortexAlembicPoints",$importAttach,1,1);
      if($reader == "")
      {
        $reader = exocortexCreateOrReuseNode("ExocortexAlembicPoints","ExocortexAlembicPoints",$importAttach,0,0);
        addAttr -ln "rgbPP" -dt vectorArray $shape;
        addAttr -ln "opacityPP" -dt doubleArray $shape;
      }
      exocortexConnectIfUnconnected(($reader+".output[0]"), ($shape+".newParticles[0]"));
      exocortexConnectIfUnconnected(($timeControl+".outTime"), ($shape+".currentTime"));
      setAttr ($shape+".conserve") 0;
    }
    else if($types[$i] == "Camera")
    {
      $shape = exocortexCreateOrReuseNode($name,"camera",$importAttach,0,0);
      $reader = exocortexCreateOrReuseNode($shape+".focalLength","ExocortexAlembicCamera",$importAttach,1,0);
      exocortexConnectIfUnconnected(($reader+".focalLength"), ($shape+".focalLength"));
      exocortexConnectIfUnconnected(($reader+".focusDistance"), ($shape+".focusDistance"));
      exocortexConnectIfUnconnected(($reader+".lensSqueezeRatio"), ($shape+".lensSqueezeRatio"));
      exocortexConnectIfUnconnected(($reader+".horizontalFilmAperture"), ($shape+".horizontalFilmAperture"));
      exocortexConnectIfUnconnected(($reader+".verticalFilmAperture"), ($shape+".verticalFilmAperture"));
      exocortexConnectIfUnconnected(($reader+".horizontalFilmOffset"), ($shape+".horizontalFilmOffset"));
      exocortexConnectIfUnconnected(($reader+".verticalFilmOffset"), ($shape+".verticalFilmOffset"));
      //exocortexConnectIfUnconnected(($reader+".nearClippingPlane"), ($shape+".nearClippingPlane"));
      //exocortexConnectIfUnconnected(($reader+".farClippingPlane"), ($shape+".farClippingPlane"));
      exocortexConnectIfUnconnected(($reader+".fStop"), ($shape+".fStop"));
      exocortexConnectIfUnconnected(($reader+".shutterAngle"), ($shape+".shutterAngle"));
    }
    else if($types[$i] == "Xform")
    {
      // if we have only transforms in the alembic file, this is a transform cache!
      if($nbTransforms == size($types))
      {
        string $locator = exocortexCreateOrReuseNode(($name+"Shape"),"locator",$importAttach,0,0);
        $xform = `listRelatives -p $locator`;
        $shape = $xform[0];
        $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
        exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
        exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
        exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));
      }
      else
      {
        // let's look for the next element in the list
        // and access its parent
        $reader = "";
        for($j=$i+1;$j<size($identifiers);$j=$j+1)
        {
          string $substring = `substring $identifiers[$j] 1 (size($identifiers[$i])+1)`;
          if($substring == ($identifiers[$i]+"/"))
          {
            $shape = $objects[$j];
            $xform = `listRelatives -p $shape`;
            $shape = `rename -ignoreShape $xform[0] $name`;
            $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
            exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
            exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
            exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));
            break;
          }
        }
      }
      if($reader == "")
        continue;
    }
    else if($types[$i] == "Group")
    {
      // find all xforms below this
      if($nbTransforms == size($types))
      {
        string $locator = exocortexCreateOrReuseNode(($name+"Shape"),"locator",$importAttach,0,0);
        $xform = `listRelatives -p $locator`;
        $shape = $xform[0];
        $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
      }
      else
      {
        $shape = exocortexCreateOrReuseNode($name,"transform",$importAttach,0,0);
        $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
      }
      exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
      exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
      exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));

      for($j=$i+1;$j<size($identifiers);$j=$j+1)
      {
        if(($types[$j] != "Xform") && ($types[$j] != "Group"))
          continue;
        string $childParts[];
        tokenize $identifiers[$j] "/" $childParts;
        if(size($childParts) != (size($parts)+1))
          continue;
        string $identifierA = "";
        string $identifierB = "";
        for($k=0;$k<size($parts);$k=$k+1)
        {
          $identifierA = $identifierA + "/";
          $identifierB = $identifierB + "/";
          $identifierA = $identifierA + $parts[$k];
          $identifierB = $identifierB + $childParts[$k];
        }
        if($identifierA != $identifierB)
          continue;

        if($objects[$j] != "" && $objects[$j] != $shape) {
          parent $objects[$j] $shape;
        }
      }
    }
    else
    {
      print("Invalid object type "+$types[$i]+"\n");
      continue;
    }
    
    // connect the standard ports
    if($nbSamples[$i] > 1)
      exocortexConnectIfUnconnected(($timeControl+".outTime"), ($reader+".inTime"));
    exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($reader+".fileName"));
    setAttr -type "string" ($reader+".identifier") $identifiers[$i];
    $objects[$i] = $shape;
    
    // setup metadata if we have it
    ExocortexAlembic_createMetaData -f $filename -i $identifiers[$i] -o $shape;
  }
}

