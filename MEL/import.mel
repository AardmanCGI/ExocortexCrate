global proc exocortexexocortexCloseDialog(string $dialog)
{
  deleteUI -window $dialog;
}

global proc string exocortexCreateOrReuseNode(string $name, string $type, int $importAttach, int $checkConnections, int $onlyReuse)
{
  string $result;
  $result = "";
  
  if($importAttach == 1 && $name != "")
  {
    if($checkConnections)
    {
      string $node = `plugNode $name`;
      if($node != "" && `objExists $node`)
      {
        print ("searching connections on plug "+$name+" of type "+$type+"\n");
        string $source = `connectionInfo -sfd $name`;
        if($source != "")
        {
          $result = `plugNode $source`;
          print ("found connected node "+$result+"\n");
          return $result;
        }
      }
    }
    else
    {
      print ("searching for node "+$name+"\n");
      if(`objExists $name`)
      {
        print ("found existing node "+$name+"\n");
        return $name;
      }
    }
  }
  
  if($result == "" && $onlyReuse == 0)
  {
    print ("creating new node "+$name+" of type "+$type+"\n");
    $result = `createNode -name $name $type`;
  }
    
  return $result;
}

global proc exocortexConnectIfUnconnected(string $source, string $target)
{
  string $currentSource = `connectionInfo -sfd $target`;
  if($currentSource != $source)
    connectAttr $source $target;
}

global proc exocortexAlembicImport(string $filename,string $dialog)
{
  // parse all options
  int $importNormals = `checkBox -q -value normals`;
  int $importUvs = `checkBox -q -value uvs`;
  int $importFaceSets = `checkBox -q -value facesets`;
  string $importVisibility = `optionMenu -q -value visibility`;
  int $importAttach = `checkBox -q -value attach`;
  exocortexCloseDialog($dialog);
  
  // check if the filename is valid
  if($filename == "")
  {
    $files = `fileDialog2 -ds 2 -cap "Choose the Alembic File To Import" -ff "Alembic Files (*.abc)" -fm 1`;
    print $files;
    if(size($files) == 0)
    {
      print("Import aborted by user.");
      return;
    }
    $filename = $files[0];
  }
  
  // check if the file exists
  string $resolvedPath = `ExocortexAlembic_resolvePath -f $filename`;
  if(!`filetest -r $resolvedPath`)
  {
    error ("File "+$filename+" does not exist!");
    return;
  }
  
  // query the content of the file
  string $infos[] = `ExocortexAlembic_getInfo -f $filename`;
  string $identifiers[];
  string $types[];
  int $nbTransforms = 0;
  string $names[];
  string $nodes[];
  string $datas[];
  int $nbSamples[];
  for($i=0; $i<size($infos); $i=$i+1)
  {
    // tokenize the basic arguments
    string $tokens[];
    tokenize $infos[$i] "|" $tokens;
    if(size($tokens) < 4)
    {
      print ("Skipping invalid info "+$infos[$i]+".");
      continue;
    }

    // extract the information
    string $identifier = $tokens[0];
    string $type = $tokens[1];
    if($type == "Xform")
      $nbTransforms = $nbTransforms + 1;
    string $name = $tokens[2];
    string $node = `ExocortexAlembic_getNodeFromIdentifier -i $identifier`;
    
    // try to find the identifier in the map
    int $skip = 0;
    for($j=0;$j<size($identifiers);$j=$j+1)
    {
      if($identifiers[$j] == $identifier)
      {
        print("Skipping duplicate identifier "+$identifier+".");
        $skip = 1;
        break;
      }
    }
    if($skip)
      break;

    // push the identifier to our map      
    $identifiers[size($identifiers)] = $identifier;
    $types[size($types)] = $type;
    $names[size($names)] = $tokens[2];
    $nodes[size($nodes)] = $node;
    $nbSamples[size($nbSamples)] = $tokens[3];
    
    // parse the forth token
    string $data = "";
    if(size($tokens)>4)
      $data = $tokens[4];
    $datas[size($datas)] = $data;
  }
  
  // now we need to determine the group types
  // group are alembic are xforms which have xforms
  // below them. for that we can loop on all identifiers
  // and find any identifier below it of type xform
  for($i=0; $i<size($identifiers); $i=$i+1)
  {
    if($types[$i] != "Xform")
      continue;
    for($j=$i+1;$j<size($identifiers); $j=$j+1)
    {
      if($types[$j] != "Xform")
        continue;
      if(size($identifiers[$i]) >= size($identifiers[$j]))
        continue;
      string $substring = `substring $identifiers[$j] 1 (size($identifiers[$i])+1)`;
      if($substring == ($identifiers[$i]+"/"))
      {
        $types[$i] = "Group";
        break;
      }
    }
  }

  // let's create the time node and file node
  $timeControl = exocortexCreateOrReuseNode("ExocortexAlembicTimeControl","ExocortexAlembicTimeControl",$importAttach,0,0);
  exocortexConnectIfUnconnected("time1.outTime",($timeControl+".inTime"));
  $fileNode = exocortexCreateOrReuseNode("ExocortexAlembicFile","ExocortexAlembicFile",0,0,0);
  setAttr -type "string" ($fileNode+".fileName ") $filename;
  
  print "parsing file...";
  
  // now let's create all items
  string $objects[];
  for($i=0;$i<size($identifiers);$i=$i+1)
    $objects[$i] = "";
  for($i=(size($identifiers)-1);$i>=0;$i=$i-1)
  {
    string $parts[];
    tokenize $identifiers[$i] "/" $parts;
    string $name = $names[$i];
    string $reader;
    string $topoReader;
    string $shape;
    
    // parse additional data options
    int $purepointcache = 0;
    int $dynamictopology = 0;
    string $data[];
    tokenize $datas[$i] ";" $data;
    for($j=0;$j<size($data);$j=$j+1)
    {
      if($data[$j]=="purepointcache=1")
        $purepointcache = 1;
      else if($data[$j]=="dynamictopology=1")
        $dynamictopology = 1;
    }

    if($types[$i] == "PolyMesh")
    {
      $shape = exocortexCreateOrReuseNode($name,"mesh",$importAttach,0,$purepointcache);
      if($shape == "")
      {
        error ("Mesh '"+$name+"' not found for purepointcache alembic import.");
        return;
      }
      if($dynamictopology == 1)
        $reader = exocortexCreateOrReuseNode($name+".inMesh","ExocortexAlembicPolyMesh",$importAttach,1,1);
      else
        $reader = exocortexCreateOrReuseNode($name+".inMesh","ExocortexAlembicPolyMeshDeform",$importAttach,1,1);
      if($reader == "")
      {
        if($purepointcache == 0)
        {
          $topoReader = exocortexCreateOrReuseNode("ExocortexAlembicPolyMesh","ExocortexAlembicPolyMesh",0,0,0);
          exocortexConnectIfUnconnected(($topoReader+".outMesh"), ($shape+".inMesh"));
          exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($topoReader+".fileName"));
          setAttr -type "string" ($topoReader+".identifier") $identifiers[$i];
          setAttr ($topoReader+".normals") $importNormals;
          setAttr ($topoReader+".uvs") $importUvs;
          if($importFaceSets)
            ExocortexAlembic_createFaceSets -f $filename -i $identifiers[$i] -o $shape;
          if($dynamictopology == 1)
            $reader = $topoReader;
        }
        if($reader == "")
        {
          string $readers[] = `deformer -type "ExocortexAlembicPolyMeshDeform" $shape`;
          $reader = $readers[0];
        }
      }
    }
    else if($types[$i] == "SubD")
    {
      $shape = exocortexCreateOrReuseNode($name,"subdiv",$importAttach,0,$purepointcache);
      if($shape == "")
      {
        error ("Subdiv '"+$name+"' not found for purepointcache alembic import.");
        return;
      }
      if($dynamictopology == 1)
        $reader = exocortexCreateOrReuseNode($name+".create","ExocortexAlembicSubD",$importAttach,1,1);
      else
        $reader = exocortexCreateOrReuseNode($name+".create","ExocortexAlembicSubDDeform",$importAttach,1,1);
      if($reader == "")
      {
        if($purepointcache == 0)
        {
          $topoReader = exocortexCreateOrReuseNode("ExocortexAlembicSubD","ExocortexAlembicSubD",0,0,0);
          exocortexConnectIfUnconnected(($topoReader+".outSubdiv"), ($shape+".create"));
          exocortexConnectIfUnconnected(($topoReader+".dispResolution"), ($shape+".dispResolution"));
          exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($topoReader+".fileName"));
          setAttr -type "string" ($topoReader+".identifier") $identifiers[$i];
          setAttr ($topoReader+".uvs") $importUvs;
          if($importFaceSets)
            ExocortexAlembic_createFaceSets -f $filename -i $identifiers[$i] -o $shape;
          if($dynamictopology == 1)
            $reader = $topoReader;
        }
        if($reader == "")
        {
          string $readers[] = `deformer -type "ExocortexAlembicSubDDeform" $shape`;
          $reader = $readers[0];
        }
      }
    }
    else if($types[$i] == "Camera")
    {
      $shape = exocortexCreateOrReuseNode($name,"camera",$importAttach,0,0);
      $reader = exocortexCreateOrReuseNode($shape+".focalLength","ExocortexAlembicCamera",$importAttach,1,0);
      exocortexConnectIfUnconnected(($reader+".focalLength"), ($shape+".focalLength"));
      exocortexConnectIfUnconnected(($reader+".focusDistance"), ($shape+".focusDistance"));
      exocortexConnectIfUnconnected(($reader+".lensSqueezeRatio"), ($shape+".lensSqueezeRatio"));
      exocortexConnectIfUnconnected(($reader+".horizontalFilmAperture"), ($shape+".horizontalFilmAperture"));
      exocortexConnectIfUnconnected(($reader+".verticalFilmAperture"), ($shape+".verticalFilmAperture"));
      exocortexConnectIfUnconnected(($reader+".horizontalFilmOffset"), ($shape+".horizontalFilmOffset"));
      exocortexConnectIfUnconnected(($reader+".verticalFilmOffset"), ($shape+".verticalFilmOffset"));
      //exocortexConnectIfUnconnected(($reader+".nearClippingPlane"), ($shape+".nearClippingPlane"));
      //exocortexConnectIfUnconnected(($reader+".farClippingPlane"), ($shape+".farClippingPlane"));
      exocortexConnectIfUnconnected(($reader+".fStop"), ($shape+".fStop"));
      exocortexConnectIfUnconnected(($reader+".shutterAngle"), ($shape+".shutterAngle"));
    }
    else if($types[$i] == "Xform")
    {
      // if we have only transforms in the alembic file, this is a transform cache!
      if($nbTransforms == size($types))
      {
        string $locator = exocortexCreateOrReuseNode(($name+"Shape"),"locator",$importAttach,0,0);
        $xform = `listRelatives -p $locator`;
        $shape = $xform[0];
        $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
        exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
        exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
        exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));
      }
      else
      {
        // let's look for the next element in the list
        // and access its parent
        $reader = "";
        for($j=$i+1;$j<size($identifiers);$j=$j+1)
        {
          string $substring = `substring $identifiers[$j] 1 (size($identifiers[$i])+1)`;
          if($substring == ($identifiers[$i]+"/"))
          {
            $shape = $objects[$j];
            $xform = `listRelatives -p $shape`;
            $shape = `rename -ignoreShape $xform[0] $name`;
            $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
            exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
            exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
            exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));
            break;
          }
        }
      }
      if($reader == "")
        continue;
    }
    else if($types[$i] == "Group")
    {
      // find all xforms below this
      if($nbTransforms == size($types))
      {
        string $locator = exocortexCreateOrReuseNode(($name+"Shape"),"locator",$importAttach,0,0);
        $xform = `listRelatives -p $locator`;
        $shape = $xform[0];
        $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
      }
      else
      {
        $shape = exocortexCreateOrReuseNode($name,"transform",$importAttach,0,0);
        $reader = exocortexCreateOrReuseNode($shape+".translate","ExocortexAlembicXform",$importAttach,1,0);
      }
      exocortexConnectIfUnconnected(($reader+".translate"), ($shape+".translate"));
      exocortexConnectIfUnconnected(($reader+".rotate"), ($shape+".rotate"));
      exocortexConnectIfUnconnected(($reader+".scale"), ($shape+".scale"));

      for($j=$i+1;$j<size($identifiers);$j=$j+1)
      {
        if(($types[$j] != "Xform") && ($types[$j] != "Group"))
          continue;
        string $childParts[];
        tokenize $identifiers[$j] "/" $childParts;
        if(size($childParts) != (size($parts)+1))
          continue;
        string $identifierA = "";
        string $identifierB = "";
        for($k=0;$k<size($parts);$k=$k+1)
        {
          $identifierA = $identifierA + "/";
          $identifierB = $identifierB + "/";
          $identifierA = $identifierA + $parts[$k];
          $identifierB = $identifierB + $childParts[$k];
        }
        if($identifierA != $identifierB)
          continue;
        if($objects[$j] != "")
          parent $objects[$j] $shape;
      }
    }
    else
    {
      print("Invalid object type "+$types[$i]+"\n");
      continue;
    }
    
    // connect the standard ports
    if($nbSamples[$i] > 1)
      exocortexConnectIfUnconnected(($timeControl+".outTime"), ($reader+".inTime"));
    exocortexConnectIfUnconnected(($fileNode+".outFileName"), ($reader+".fileName"));
    setAttr -type "string" ($reader+".identifier") $identifiers[$i];
    $objects[$i] = $shape;
    
    // setup metadata if we have it
    ExocortexAlembic_createMetaData -f $filename -i $identifiers[$i] -o $shape;
  }
}

global proc exocortexCloseDialog(string $dialog)
{
  deleteUI -window $dialog;
}

global proc exocortexChooseFile(string $dialog)
{
  exocortexAlembicImport("",$dialog);
}

global proc exocortexSetupDialog(string $uiDirectory)
{
  global string $dialog;
  if (`window -exists $dialog`)
    deleteUI -window $dialog;

  $dialog = `loadUI -uiFile ($uiDirectory+"/ExocortexAlembicImport.ui")`;
  showWindow $dialog;
}


