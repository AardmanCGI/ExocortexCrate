// alembicPlugin
// Initial code generated by Softimage SDK Wizard
// Executed Fri Aug 19 09:14:49 UTC+0200 2011 by helge
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include "stdafx.h"
#include "arnoldHelpers.h" 

using namespace XSI; 
using namespace MATH; 

#include "AlembicLicensing.h"

#include "AlembicWriteJob.h"
#include "AlembicPoints.h"
#include "AlembicCurves.h"
#include "CommonProfiler.h"
#include "CommonMeshUtilities.h"
#include "CommonUtilities.h"
#include "CommonAbcCache.h"
#include "CommonImport.h"
#include "sceneGraph.h"

ESS_CALLBACK_START(alembic_import_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"filename");
   oArgs.Add(L"normals");
   oArgs.Add(L"uvs");
   oArgs.Add(L"clusters");
   oArgs.Add(L"visibility");
   oArgs.Add(L"standins");
   oArgs.Add(L"bboxes");
   oArgs.Add(L"attach");
   oArgs.Add(L"failOnUnsupported");
   oArgs.Add(L"identifiers");
	return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_import_jobs_Init,CRef&)

	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"importjobs");
	return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_create_item_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"type");
   oArgs.Add(L"target");
   oArgs.Add(L"file");
   oArgs.Add(L"identifier");
   oArgs.Add(L"reattach");
   oArgs.Add(L"timecontrolprop");
   oArgs.Add(L"facesets");
   oArgs.Add(L"normals");
   oArgs.Add(L"uvs");
   oArgs.Add(L"bindpose");
	return CStatus::OK;
ESS_CALLBACK_END


enum alembicItemType{
   alembicItemType_xform,
   alembicItemType_camera,
   alembicItemType_polymesh_topo,
   alembicItemType_bbox,
   alembicItemType_polymesh,
   alembicItemType_crvlist_topo,
   alembicItemType_crvlist,
   alembicItemType_curves,
   alembicItemType_points,
   alembicItemType_metadata,
   alembicItemType_timecontrol,
   alembicItemType_visibility,
   alembicItemType_geomapprox,
   alembicItemType_standin,
   alembicItemType_nurbs,
   alembicItemType_none
};

std::map<std::string,alembicItemType> gItemTypeMap;

CStatus alembic_create_item_Invoke
(
   const CString & type,
   const CRef& importRootNode, 
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting,
   const CValueArray & args,
   CValue & returnVal
)
{
	ESS_PROFILE_SCOPE("alembic_create_item_Invoke");

	// fill the map in case it is empty
   if(gItemTypeMap.size() == 0)
   {
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_xform",alembicItemType_xform));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_camera",alembicItemType_camera));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_polymesh_topo",alembicItemType_polymesh_topo));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_bbox",alembicItemType_bbox));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_polymesh",alembicItemType_polymesh));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_crvlist_topo",alembicItemType_crvlist_topo));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_crvlist",alembicItemType_crvlist));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_curves",alembicItemType_curves));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_points",alembicItemType_points));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_metadata",alembicItemType_metadata));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_timecontrol",alembicItemType_timecontrol));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_visibility",alembicItemType_visibility));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_geomapprox",alembicItemType_geomapprox));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_standin",alembicItemType_standin));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_nurbs",alembicItemType_nurbs));
   }

   // query the item type from the map
   CString realType(type);
   realType.Lower();
   std::map<std::string,alembicItemType>::iterator it = gItemTypeMap.find(realType.GetAsciiString());
   alembicItemType itemType = alembicItemType_none;
   if(it != gItemTypeMap.end())
      itemType = it->second;

   // cast into the standard types
   X3DObject x3d(target);
   Primitive prim(target);

   // now let's find the real target for this
   CRef realTarget;
   { ESS_PROFILE_SCOPE("alembic_create_item_Invoke find_real_target");
   switch(itemType)
   {
      case alembicItemType_xform:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetKinematics().GetLocal().GetRef();
         else
         {
            KinematicState kine(target);
            if(kine.IsValid())
               realTarget = target;
            else
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      {
         if(x3d.IsValid())
         {
            Property visProp;
            if(itemType == alembicItemType_visibility)
               x3d.GetPropertyFromName(L"Visibility",visProp);
            else
            {
               x3d.GetPropertyFromName(L"GeomApprox",visProp);
            }
            realTarget = visProp.GetRef();
         }
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_camera:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetActivePrimitive().GetRef();
         else if(prim.IsValid())
            realTarget = prim.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(!Primitive(realTarget).GetType().IsEqualNoCase(L"camera"))
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_points:
      case alembicItemType_nurbs:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetActivePrimitive().GetRef();
         else if(prim.IsValid())
            realTarget = prim.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         // now check the type as well
         if(itemType == alembicItemType_polymesh_topo || itemType == alembicItemType_polymesh)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"polymsh"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_crvlist_topo || itemType == alembicItemType_crvlist)
         {
			CString type = Primitive(realTarget).GetType();
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"crvlist") && 
			   !Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud") &&
			   !Primitive(realTarget).GetType().IsEqualNoCase(L"hair"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_points || itemType == alembicItemType_curves)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_nurbs)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"surfmsh"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      case alembicItemType_metadata:
      case alembicItemType_timecontrol:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_standin:
      {
         CustomOperator alembicOp(target);
         ICETree alembicTree(target);
         if(!alembicOp.IsValid() && !alembicTree.IsValid())
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(!alembicOp.GetType().GetSubString(0,8).IsEqualNoCase(L"alembic_") && !alembicTree.GetName().GetSubString(0,4).IsEqualNoCase(L"abc_"))
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(alembicOp.IsValid())
            realTarget = alembicOp.GetRef();
         else
         {
            // loop for the first custom node
            CRefArray compounds = alembicTree.GetCompoundNodes();
            for(LONG j=0;j<compounds.GetCount();j++)
            {
               ICECompoundNode compound(compounds[j]);
               CRefArray nodes = compound.GetNodes();
               for(LONG k=0;k<nodes.GetCount();k++)
               {
                  CString nodeType = ICENode(nodes[k]).GetType();
                  if(nodeType.GetSubString(0,8).IsEqualNoCase(L"alembic_"))
                  {
                     realTarget = nodes[k];
                     break;
                  }
               }

               if(realTarget.IsValid())
                  break;
            }

            if(!realTarget.IsValid())
            {
               Application().LogMessage(L"[ExocortexAlembic] Could not find custom abc node on icetree '"+target.GetAsText()+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      default:
      {
         Application().LogMessage(L"[ExocortexAlembic] Unknown item type '"+type+L"'.",siErrorMsg);
         return CStatus::InvalidArgument;
      }
   }
   }

   // now validate the identifier if necessary
   Abc::IObject abcObject;
   AbcObjectCache *pObjectCache = NULL;
   bool isAnimated = false;
   { ESS_PROFILE_SCOPE("alembic_create_item_Invoke validate_the_identifier");
   switch(itemType)
   {
      case alembicItemType_xform:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_metadata:
      case alembicItemType_points:
      case alembicItemType_geomapprox:
      case alembicItemType_nurbs:
      {
        pObjectCache = getObjectCacheFromArchive( std::string( file.GetAsciiString() ), std::string( identifier.GetAsciiString() ) );
         if(pObjectCache == NULL || !pObjectCache->obj.valid())
         {
           EC_LOG_ERROR("[ExocortexAlembic] Identifier '" << identifier.GetAsciiString() << "' is not valid for given filename: " << file.GetAsciiString() );
            return CStatus::InvalidArgument;
         }
         abcObject = pObjectCache->obj;
         isAnimated = (itemType == alembicItemType_bbox) || (! pObjectCache->isConstant && itemType != alembicItemType_geomapprox);
         break;
      }
      case alembicItemType_visibility:
      {
        pObjectCache = getObjectCacheFromArchive( std::string( file.GetAsciiString() ), std::string( identifier.GetAsciiString() ) );
         if(pObjectCache == NULL || !pObjectCache->obj.valid())
         {
           EC_LOG_ERROR("[ExocortexAlembic] Identifier '" << identifier.GetAsciiString() << "' is not valid for given filename: " << file.GetAsciiString() );
            return CStatus::InvalidArgument;
         }
         abcObject = pObjectCache->obj;
         AbcG::IVisibilityProperty visibilityProperty = 
            AbcG::GetVisibilityProperty(abcObject);
         if(!visibilityProperty.valid())
         {
            return CStatus::InvalidArgument;
         }
         isAnimated = visibilityProperty.getNumSamples() > 1;
         break;
      }
      case alembicItemType_standin:
      default:
         break;
   }
   }

    // check if we have a timecontrol in the args
    CustomProperty timeControlProp;
    CRef timeControlRef;
    if(args.GetCount() > 0)
       timeControlRef = args[0];
    timeControlProp = timeControlRef;
	CValue setExprReturn;
    CValueArray setExprArgs(2);  
	CString expressionString;
    if(timeControlProp.IsValid())
    {
       setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
	   expressionString = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
    }

    { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator");
   // now create an operator...?
   switch(itemType)
   {
      case alembicItemType_xform:
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_nurbs:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_xxx");
		// for visibility, let's see if we should create an operator
         if(itemType == alembicItemType_visibility)
         {
            bool importVis = args[4];
            if(!importVis)
            {
               // this means skip the creation of the operator
               AbcG::IVisibilityProperty visibilityProperty = 
                  AbcG::GetVisibilityProperty(abcObject);
               if(visibilityProperty.valid())
               {
                  int rawVisibilityValue = visibilityProperty.getValue ( size_t(0) );
                  AbcG::ObjectVisibility visibilityValue = AbcG::ObjectVisibility ( rawVisibilityValue );

                  Property prop(realTarget);
                  switch(visibilityValue)
                  {
                     case AbcG::kVisibilityVisible:
                     {
                        prop.PutParameterValue(L"viewvis",true);
                        prop.PutParameterValue(L"rendvis",true);
                        break;
                     }
                     case AbcG::kVisibilityHidden:
                     {
                        prop.PutParameterValue(L"viewvis",false);
                        prop.PutParameterValue(L"rendvis",false);
                        break;
                     }
                     default:
                     {
                        break;
                     }
                  }
                  break;
               }
            }
         }

         // for xform, disable softimage scaling
         if(itemType == alembicItemType_xform)
            KinematicState(realTarget).PutParameterValue(L"siscaling",false);

         CustomOperator op;
         if(attachToExisting)
         {
            CRef opRef;
            opRef.Set(realTarget.GetAsText()+L"."+realType);
            op = opRef;
         }
         if(!op.IsValid())
         {
			 {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator CreateObject");
		    op = Application().GetFactory().CreateObject(realType);
			 }

		/*	 		// Duplicate arc 4 times and translate in y
		args.Resize(19);
		args[0] = arc;					// source object
		args[1] = (LONG)4;				// number of copies
		args[9] = (LONG)siApplyRepeatXForm;	// Xform
		args[18] = (double)1;			// Ty
		app.ExecuteCommand( L"Duplicate", args, outArg );*/
			 
			 { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator AddPorts");
            op.AddOutputPort(realTarget);
            op.AddInputPort(realTarget);
			 }

            siConstructionMode consMode = siConstructionModeModeling;
            if(itemType != alembicItemType_crvlist_topo && itemType != alembicItemType_polymesh_topo)
               consMode = siConstructionModeAnimation;
			 { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator Connect");
			
				op.Connect(consMode);
			 }
         }
 
         // setup the operator
         addRefArchive(file);
         op.PutParameterValue(L"path",file);
         op.PutParameterValue(L"identifier",identifier);

         // store the return value
         returnVal = op.GetRef();

         // if we are not a topo op, let's connect to the timecontrol
         bool receivesExpression = isAnimated;
         if(itemType == alembicItemType_crvlist_topo)
            receivesExpression = false;
         else if(itemType == alembicItemType_polymesh_topo)
         {
            // check if the compound has more than one sample on its facecounts
            Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
            Abc::IInt32ArrayProperty faceCountProp = Abc::IInt32ArrayProperty(abcCompound,".faceCounts");
            if(faceCountProp.valid())
               receivesExpression = !faceCountProp.isConstant();
            else
               receivesExpression = false;
         }

         if(receivesExpression)
         {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator receivesExpression");

            // check if we have a timecontrol in the args
             if(timeControlProp.IsValid())
            {
				 //setExprArgs[0] = op.GetFullName()+L".time";
				 op.GetParameter("time").AddExpression( expressionString );
				//Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
            }
         }

         // if we are a polygon mesh topo op, oh dear
         if(itemType == alembicItemType_polymesh_topo && args.GetCount() > 3)
         {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo");

            bool importClusters = args[1];
            bool importNormals = args[2];
            bool importUvs = args[3];

            AbcG::IPolyMesh abcMesh;
            AbcG::ISubD abcSubD;
            if(AbcG::IPolyMesh::matches(abcObject.getMetaData()))
               abcMesh = AbcG::IPolyMesh(abcObject,Abc::kWrapExisting);
            else
               abcSubD = AbcG::ISubD(abcObject,Abc::kWrapExisting);
            if(!abcMesh.valid() && !abcSubD.valid())
               return CStatus::OK;

            PolygonMesh meshGeo = Primitive(realTarget).GetGeometry();
            if(importClusters)
            {
        	  ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importClusters");
		       std::vector<std::string> faceSetNames;
               if(abcMesh.valid())
                  abcMesh.getSchema().getFaceSetNames(faceSetNames);
               else
                  abcSubD.getSchema().getFaceSetNames(faceSetNames);
               for(size_t j=0;j<faceSetNames.size();j++)
               {
                  if(attachToExisting)
                  {
                     if(meshGeo.GetClusters().GetItem(CString(faceSetNames[j].c_str())).IsValid())
                        continue;
                  }
                  AbcG::IFaceSetSchema faceSet;
                  if(abcMesh.valid())
                     faceSet = abcMesh.getSchema().getFaceSet(faceSetNames[j]).getSchema();
                  else
                     faceSet = abcSubD.getSchema().getFaceSet(faceSetNames[j]).getSchema();
                  AbcG::IFaceSetSchema::Sample faceSetSample = faceSet.getValue();
                  Abc::Int32ArraySamplePtr faces = faceSetSample.getFaces();
                  CLongArray elements((LONG)faces->size());
                  for(size_t k=0;k<faces->size();k++)
                     elements[(LONG)k] = (LONG)faces->get()[k];
                  Cluster cluster;
                  meshGeo.AddCluster(L"poly",CString(faceSetNames[j].c_str()),elements,cluster);
               }
            }
            if(importNormals && abcMesh.valid())
            {
              ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importNormals");
		       AbcG::IN3fGeomParam meshNormalsParam = abcMesh.getSchema().getNormalsParam();
               if(meshNormalsParam.valid())
               {
                  Abc::N3fArraySamplePtr meshNormals = meshNormalsParam.getExpandedValue(0).getVals();

                  CRef clusterPropRef;
                  if(attachToExisting)
                     clusterPropRef.Set(realTarget.GetAsText()+L".cls.User_Normal_Cluster.User_Normal_Property");
                  if(!clusterPropRef.IsValid())
                  {
                     // create user normals
                     CValue createUserNormalReturnVal;
                     CValueArray createUserNormalArgs(1);
                     createUserNormalArgs[0] = Primitive(realTarget).GetParent3DObject().GetFullName();
                     Application().ExecuteCommand(L"CreateUserNormals",createUserNormalArgs,createUserNormalReturnVal);
                  }
                  ClusterProperty userNormalProp;
                  CRefArray clusters = meshGeo.GetClusters();
                  for(LONG j=0;j<clusters.GetCount();j++)
                  {
                     Cluster cluster(clusters[j]);
                     if(!cluster.GetType().IsEqualNoCase(L"sample"))
                        continue;
                     CRefArray props(cluster.GetLocalProperties());
                     for(LONG k=0;k<props.GetCount();k++)
                     {
                        ClusterProperty prop(props[k]);
                        if(prop.GetType().IsEqualNoCase(L"normal"))
                        {
                           userNormalProp = props[k];
                           break;
                        }
                     }
                     if(userNormalProp.IsValid())
                        break;
                  }
                  if(userNormalProp.IsValid())
                  {
                     // we found it, and we need to attach the op
                     CustomOperator op;
                     if(attachToExisting)
                     {
                        CRef opRef;
                        opRef.Set(userNormalProp.GetFullName()+L".alembic_normals");
                        op = opRef;
                     }
                     if(!op.IsValid())
                     {
                        op = Application().GetFactory().CreateObject(L"alembic_normals");
                        op.AddOutputPort(userNormalProp.GetRef());
                        op.AddInputPort(userNormalProp.GetRef());
                        op.AddInputPort(realTarget);
                        op.Connect();
                     }
                     addRefArchive(file);
                     op.PutParameterValue(L"path",file);
                     op.PutParameterValue(L"identifier",identifier);
                     if(!timeControlProp.IsValid())
                     {
                        CRef timeControlRef;
                        if(args.GetCount() > 0)
                           timeControlRef = args[0];
                        timeControlProp = timeControlRef;
                     }
                     if(timeControlProp.IsValid())
                     {
                        CValue setExprReturn;
                        CValueArray setExprArgs(2);
                        setExprArgs[0] = op.GetFullName()+L".time";
                        setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
                        Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
                     }
                  }
               }
            }
            if(importUvs)
            {
                ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importUvs");
				AbcG::IV2fGeomParam meshUVsParam;
               if(abcMesh.valid())
                  meshUVsParam = abcMesh.getSchema().getUVsParam();
               else
                  meshUVsParam = abcSubD.getSchema().getUVsParam();
               if(meshUVsParam.valid())
               {
                 // check if we have a uv set names prop
                 CStringArray uvSetNames;
                 if(abcMesh.valid())
                 {
                    if ( abcMesh.getSchema().getPropertyHeader( ".uvSetNames" ) != NULL )
                    {
                       Abc::IStringArrayProperty uvSetNamesProp = Abc::IStringArrayProperty( abcMesh.getSchema(), ".uvSetNames" );
                       Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                       for(size_t i=0;i<ptr->size();i++)
                          uvSetNames.Add(CString(ptr->get()[i].c_str()));
                    }
                 }
                 else
                 {
                    if ( abcSubD.getSchema().getPropertyHeader( ".uvSetNames" ) != NULL )
                    {
                       Abc::IStringArrayProperty uvSetNamesProp = Abc::IStringArrayProperty( abcSubD.getSchema(), ".uvSetNames" );
                       Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                       for(size_t i=0;i<ptr->size();i++)
                          uvSetNames.Add(CString(ptr->get()[i].c_str()));
                    }
                 }
                 if(uvSetNames.GetCount() == 0)
                    uvSetNames.Add(L"Texture_Projection");

                 // for each uv set name
                 for(LONG uvI=0; uvI < uvSetNames.GetCount(); uvI++)
                 {
                    CRef clusterPropRef;
                    if(attachToExisting)
                       clusterPropRef.Set(realTarget.GetAsText()+L".cls.Texture_Coordinates_AUTO."+uvSetNames[uvI]);
                    if(!clusterPropRef.IsValid())
                    {
                       // create user normals
                       CValue createProjectionReturnVal;
                       CValueArray createProjectionArgs(5);
                       createProjectionArgs[0] = Primitive(realTarget).GetParent3DObject().GetFullName();
                       createProjectionArgs[1] = siTxtPureImplicit;
                       createProjectionArgs[2] = siTxtDefaultPlanarXY;
                       createProjectionArgs[3] = L"";
                       createProjectionArgs[4] = uvSetNames[uvI];
                       Application().ExecuteCommand(L"CreateProjection",createProjectionArgs,createProjectionReturnVal);
                    }
                    ClusterProperty uvProp;
                    CRefArray clusters = meshGeo.GetClusters();
                    for(LONG j=0;j<clusters.GetCount();j++)
                    {
                       Cluster cluster(clusters[j]);
                       if(!cluster.GetType().IsEqualNoCase(L"sample"))
                          continue;
                       CRefArray props(cluster.GetLocalProperties());
                       for(LONG k=0;k<props.GetCount();k++)
                       {
                          ClusterProperty prop(props[k]);
                          if(prop.GetType().IsEqualNoCase(L"uvspace") && prop.GetName().IsEqualNoCase(uvSetNames[uvI]))
                          {
                             uvProp = props[k];
                             break;
                          }
                       }
                       if(uvProp.IsValid())
                          break;
                    }
                    if(uvProp.IsValid())
                    {
                       // check if this alembic file has a uv options property
                       bool hasUvOptions = false;
                       if(abcMesh.valid())
                          hasUvOptions = abcMesh.getSchema().getPropertyHeader( ".uvOptions" ) != NULL;
                       else
                          hasUvOptions = abcSubD.getSchema().getPropertyHeader( ".uvOptions" ) != NULL;
                       if(hasUvOptions)
                       {
                          Abc::IFloatArrayProperty prop;
                          if(abcMesh.valid())
                             prop = Abc::IFloatArrayProperty( abcMesh.getSchema(), ".uvOptions" );
                          else
                             prop = Abc::IFloatArrayProperty( abcSubD.getSchema(), ".uvOptions" );

                          // if the prop stores any data
                          if(prop.getNumSamples() > 0)
                          {
                             Abc::FloatArraySamplePtr ptr = prop.getValue(0);
                             if(ptr->size() > 2 * uvI + 1)
                             {
                                bool uWrap = ptr->get()[uvI * 2 + 0] != 0.0f;
                                bool vWrap = ptr->get()[uvI * 2 + 1] != 0.0f;

                                CRefArray children = uvProp.GetNestedObjects();
                                for(LONG i=0; i<children.GetCount(); i++)
                                {
                                   ProjectItem child(children.GetItem(i));
                                   CString type = child.GetType();
                                   if(type == L"uvprojdef")
                                   {
                                      child.GetParameter(L"wrap_u").PutValue(uWrap);
                                      child.GetParameter(L"wrap_v").PutValue(vWrap);
                                      break;
                                   }
                                }
                             }
                          }
                       }

                       // we found it, and we need to attach the op
                       CustomOperator op;
                       if(attachToExisting)
                       {
                          CRef opRef;
                          opRef.Set(uvProp.GetFullName()+L".alembic_uvs");
                          op = opRef;
                       }
                       if(!op.IsValid())
                       {
                          op = Application().GetFactory().CreateObject(L"alembic_uvs");
                          op.AddOutputPort(uvProp.GetRef());
                          op.AddInputPort(uvProp.GetRef());
                          op.AddInputPort(realTarget);
                          op.Connect();
                       }
                       addRefArchive(file);
                       op.PutParameterValue(L"path",file);
                       op.PutParameterValue(L"identifier",identifier+CString(L":")+CString(uvI));
                       if(meshUVsParam.getNumSamples() > 1)
                       {
                          CValue setExprReturn;
                          CValueArray setExprArgs(2);
                          setExprArgs[0] = op.GetFullName()+L".time";
                          setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
                          Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
                       }
                     }
                  }
               }
            }
         }

         break;
      }
      case alembicItemType_curves:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_curves");
		// let's setup the ICE tree to load it
         ICETree iceTree;
         CValueArray treeArgs(2);
         CValue treeReturnVal;
         if(attachToExisting)
         {
            CRef treeRef;
            treeRef.Set(realTarget.GetAsText()+L".ABC_Load_Curves");
            iceTree = treeRef;
         }
         if(!iceTree.IsValid())
         {
            treeArgs[0] = L"ABC Load Curves";
            treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
            Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
            iceTree = (CRef)treeReturnVal;
         }
         ICECompoundNode node = iceTree.GetCompoundNodes()[0];
         treeArgs[0] = node.GetFullName()+L".path_string";
         treeArgs[1] = file;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         treeArgs[0] = node.GetFullName()+L".identifier_string";
         treeArgs[1] = identifier;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         if(isAnimated)
         {
            // check if we have a timecontrol in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            CustomProperty timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               treeArgs[0] = node.GetFullName()+L".TimeControl";
               treeArgs[1] = timeControlProp.GetFullName();
               Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
            }
         }

         // store the return value
         returnVal = iceTree.GetRef();
         break;
      }
      case alembicItemType_points:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_points");
				// let's setup the ICE tree to load it
         
         CValueArray treeArgs(2);
         CValue treeReturnVal;

         // we need to check if we have instances....
         AbcG::IPoints abcPoints(abcObject,Abc::kWrapExisting);
         if(!abcPoints.valid())
            return CStatus::OK;

		   Abc::IStringArrayProperty shapeInstanceNamesProp;
         if ( getArbGeomParamPropertyAlembic(abcPoints, "instancenames", shapeInstanceNamesProp) )
         {
            if(shapeInstanceNamesProp.getNumSamples() > 0)
            {
               Abc::StringArraySamplePtr shapeInstanceNamesPtr = shapeInstanceNamesProp.getValue(shapeInstanceNamesProp.getNumSamples()-1);
               if(shapeInstanceNamesPtr->size() > 0)
               {
                  ICETree iceTree;
                  if(attachToExisting)
                  {
                     CRef treeRef;
                     treeRef.Set(realTarget.GetAsText()+L".ABC_Instance_Shapes");
                     iceTree = treeRef;
                  }
                  if(!iceTree.IsValid())
                  {
                     treeArgs[0] = L"ABC Instance Shapes";
                     treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
                     Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
                     iceTree = (CRef)treeReturnVal;
                  }

                  for(size_t j=0;j<shapeInstanceNamesPtr->size();j++)
                  {
                     std::string instanceIdentifier = shapeInstanceNamesPtr->get()[j];
                     //replace spaces with underscores
                     for(int c=0; c<instanceIdentifier.size(); c++){
                        if(instanceIdentifier[c] == ' '){
                           instanceIdentifier[c] = '_';
                        }
                     }

                     CString fullName = getFullNameFromIdentifier(importRootNode,instanceIdentifier);
                     treeArgs[0] = iceTree.GetFullName()+L".ABC_Instance_Shapes.Reference"+CString((LONG)j);
                     treeArgs[1] = fullName;
                     CStatus status = Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
                     if( status != CStatus::OK ) ESS_LOG_WARNING("Failed set ABC_Instance_Shapes.Reference");

                     // also check if we have this object in the scene
                     if(hasStandinSupport())
                     {
                        CRef ref;
                        ref.Set(fullName);
                        X3DObject x3d(ref);
                        if(x3d.IsValid())
                        {
                           // disable deferred loading on the instance sources
                           CRef standinPropRef;
                           standinPropRef.Set(fullName+L".arnold_standin");
                           Property prop(standinPropRef);
                           if(prop.IsValid())
                              prop.PutParameterValue(L"deferredLoading",false);

						         // enable hiding the instance masters
                           CRef visPropRef;
                           visPropRef.Set(fullName+L".visibility");
                           prop = Property(visPropRef);
                           if(prop.IsValid())
                              prop.PutParameterValue(L"hidemaster",true);
                        }
                     }
                  }
               }
            }
         }

         ICETree iceTree;
         if(attachToExisting)
         {
            CRef treeRef;
            treeRef.Set(realTarget.GetAsText()+L".ABC_Load_Points");
            iceTree = treeRef;
         }
         if(!iceTree.IsValid())
         {
            treeArgs[0] = L"ABC Load Points";
            treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
            CStatus status = Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);\
            if( status != CStatus::OK ) ESS_LOG_WARNING("Failed to ApplyICEOp ABC_Load_Points");
            iceTree = (CRef)treeReturnVal;
         }

         ICECompoundNode node = iceTree.GetCompoundNodes()[0];
         treeArgs[0] = node.GetFullName()+L".path_string";
         treeArgs[1] = file;
         CStatus status = Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         if( status != CStatus::OK ){
            ESS_LOG_WARNING("Failed set SetValue of path_string");
            ESS_LOG_WARNING("nodeFullName: "<<node.GetFullName().GetAsciiString());
         }

         treeArgs[0] = node.GetFullName()+L".identifier_string";
         treeArgs[1] = identifier;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         if(isAnimated)
         {
            // check if we have a timeControl in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            CustomProperty timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               treeArgs[0] = node.GetFullName()+L".TimeControl";
               treeArgs[1] = timeControlProp.GetFullName();
               Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
            }
         }

         // store the return value
         returnVal = iceTree.GetRef();
         break;
      }
      case alembicItemType_metadata:
      {
			ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_metadata");
		Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
         if ( abcCompound.getPropertyHeader( ".metadata" ) == NULL )
            break;

         Abc::IStringArrayProperty metaDataProp = Abc::IStringArrayProperty( abcCompound, ".metadata" );
         Abc::StringArraySamplePtr metaDataPtr = metaDataProp.getValue(0);
         if(metaDataPtr->size() != 20)
            break;

         // check if we already have the metadataprop
         CustomProperty xsiProp;
         CRefArray props = x3d.GetLocalProperties();
         for(LONG i=0;i<props.GetCount();i++)
         {
            CustomProperty prop(props[i]);
            if(!prop.IsValid())
               continue;
            if(!prop.GetType().IsEqualNoCase(L"alembic_metadata"))
               continue;
            xsiProp = prop;
            break;
         }
         if(!xsiProp.IsValid())
            xsiProp = x3d.AddProperty(L"alembic_metadata");

         // set all values
         size_t offset = 0;
         for(LONG i=0;i<10;i++)
         {
            xsiProp.PutParameterValue(L"name"+CString(i),CString(metaDataPtr->get()[offset++].c_str()));
            xsiProp.PutParameterValue(L"value"+CString(i),CString(metaDataPtr->get()[offset++].c_str()));
         }

         // store the return value
         returnVal = xsiProp.GetRef();
         break;
      }
      case alembicItemType_timecontrol:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_timecontrol");
		 CValueArray setExprArgs(2);
         CValue setExprReturn;
         CustomProperty timeControl = (CustomProperty) x3d.AddProperty(L"alembic_timecontrol");

         // prepare values for the setexpr command
         setExprArgs[0] = timeControl.GetFullName()+L".current";
         setExprArgs[1] = L"T";
         Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);

         // store the return value
         returnVal = timeControl.GetRef();
         break;
      }
      case alembicItemType_standin:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_standin");
		 // create an arnold property on the x3d if we don't have it yet!
         if(!hasStandinSupport())
         {
            Application().LogMessage(L"[ExocortexAlembic] There is no standin support. Please use a renderer supported standins.",siErrorMsg);
            return CStatus::InvalidArgument;
         }

         X3DObject sourceX3D = ProjectItem(realTarget).GetParent3DObject();
         CString projectItemName = ProjectItem(realTarget).GetFullName();
         CString sourceX3DFullName = sourceX3D.GetFullName();

         // let's see if we have the standin property already
         CustomProperty arnoldProp;
         CRef propRef;
         propRef.Set(sourceX3D.GetFullName()+L".arnold_standin");
         if(propRef.IsValid())
         {
            arnoldProp = CustomProperty(propRef);
         }
         else
         {
            arnoldProp = sourceX3D.AddProperty(L"arnold_standin",false);
         }

         // now check if the operator alrady exists
         CRef opRef;
         opRef.Set(arnoldProp.GetFullName()+L".alembic_standinop");
         if(!opRef.IsValid())
         {
            CustomOperator op = Application().GetFactory().CreateObject(L"alembic_standinop");
            op.AddOutputPort(arnoldProp.GetRef());
            op.AddInputPort(realTarget);
            op.Connect();

            // create the timecontrol expression
            // check if we have a timecontrol in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            Property timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               CValue setExprReturn;
               CValueArray setExprArgs(2);
               setExprArgs[0] = op.GetFullName()+L".time";
               setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
               Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
            }
         }

         break;
      }
      default:
         break;
   }
   }

   return CStatus::OK;
}


CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef& importRootNode,
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting,
   const CValueArray & args
)
{
	CValue returnVal;
	alembic_create_item_Invoke( type,importRootNode, target, file, identifier, attachToExisting, args, returnVal );
	return CStatus::OK;
}

CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef& importRootNode,
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting
)
{
	CValueArray args(0);
	alembic_create_item_Invoke( type, importRootNode, target, file, identifier, attachToExisting, args );
	return CStatus::OK;
}




ESS_CALLBACK_START(alembic_create_item_Execute, CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
   CString type = args[0];
   CRef importRootNode = args[1];
   CRef target = args[2];
   CString file = args[3];
   CString identifier = args[4];
   bool reattach = args[5];
   CValueArray additionalArgs;
   for(LONG i=6;i<args.GetCount();i++)
      additionalArgs.Add(args[i]);
   CValue returnVal;
   CStatus result = alembic_create_item_Invoke(type,importRootNode,target,file,identifier,reattach,additionalArgs,returnVal);
   ctxt.PutAttribute(L"ReturnValue",returnVal);
   return result;
ESS_CALLBACK_END



//the last parameter is ignored if attach to exising is active (since we are not creating a new node)
bool createNode(SceneNodeXSI* const appNode, SceneNodeAlembic* const fileNode, const IJobStringParser& jobParams, SceneNodePtr& newAppNode)
{  
    //the appNode parameter is either the parent if adding a new node to the scene, or the node to replace if doing attach to existing

   XSI::CRef importRootNode;//This is used for building renference paths to particle system instance
   //TODO: will need to think about how this should work


   CString filename = CString(jobParams.filename.c_str());
   const bool& attachToExisting = jobParams.attachToExisting;
   //const bool& importStandins = jobParams.importStandinProperties;
   //const bool& importBboxes = jobParams.importBoundingBoxes;
   //const bool& failOnUnsupported = jobParams.failOnUnsupported;

   CRef timeRef;
   timeRef.Set(L"alembic_timecontrol");

   if(!timeRef.IsValid()){
      ESS_LOG_ERROR("Could not find alembic_timecontrol");
      return false;
   }

   //CustomProperty timeControl = timeRef;
   CValueArray createItemArgs(5);
   createItemArgs[0] = timeRef;
   createItemArgs[1] = jobParams.importFacesets;
   createItemArgs[2] = jobParams.importNormals;
   createItemArgs[3] = jobParams.importUVs;
   createItemArgs[4] = jobParams.importVisibilityControllers;

   //the transform
   
   Abc::IObject& iObj = fileNode->getObject();
   CString name = truncateName(iObj.getName().c_str());

   if(AbcG::IXform::matches(iObj.getMetaData()))
   {
      CRef nodeRef;
      if(attachToExisting){
	      ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;
        
         //if(!x3dobject.GetType().IsEqualNoCase(L"#model") && !x3dobject.GetType().IsEqualNoCase(L"null")){
         //   x3dobject.ResetObject();
         //}

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not attach xform "<<iObj.getFullName());
            return false;
         }
      }
      else{
         X3DObject parentX3DObject(appNode->nodeRef);
         Null null;
         parentX3DObject.AddNull(name, null);
         nodeRef = null.GetRef();

         if(!nodeRef.IsValid()){
             ESS_LOG_ERROR("Could not create xform "<<iObj.getFullName());
             return false;
         }

         newAppNode = SceneNodePtr(new SceneNodeXSI(nodeRef));

         //we possibly won't need the name map anymore
         nameMapAdd(iObj.getFullName().c_str(),null.GetFullName());
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, iObj.getFullName().c_str(), attachToExisting, createItemArgs);

      // load xform
      alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, iObj.getFullName().c_str(), attachToExisting, createItemArgs);
      
      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, iObj.getFullName().c_str(), attachToExisting, createItemArgs);
      
   }
   else 
   {
		std::stringstream s;
		s << "Unsupported Alembic type: " << iObj.getFullName().c_str();
		if( jobParams.failOnUnsupported ) {
			ESS_LOG_ERROR( s.str().c_str() );
			return false;
		}
		ESS_LOG_WARNING( s.str().c_str() );
   }

   return true;
}


bool createMergeableNode(SceneNodeXSI* const appNode, SceneNodeAlembic* const fileXformNode, SceneNodeAlembic* const fileShapeNode, const IJobStringParser& jobParams, SceneNodePtr& newAppNode)
{
   //the appNode parameter is either the parent if adding a new node to the scene, or the node to replace if doing attach to existing

   XSI::CRef importRootNode;//This is used for building renference paths to particle system instance
   //TODO: will need to think about how this should work


   CString& filename = CString(jobParams.filename.c_str());
   const bool& attachToExisting = jobParams.attachToExisting;
   const bool& importStandins = jobParams.importStandinProperties;
   const bool& importBboxes = jobParams.importBoundingBoxes;
   const bool& failOnUnsupported = jobParams.failOnUnsupported;
  
   CRef timeRef;
   timeRef.Set(L"alembic_timecontrol");
   //CustomProperty timeControl = timeRef;
   
   if(!timeRef.IsValid()){
      ESS_LOG_ERROR("Could not find alembic_timecontrol");
      return false;
   }

   // store the time control in a value array
   CValueArray createItemArgs(5);
   createItemArgs[0] = timeRef;
   createItemArgs[1] = jobParams.importFacesets;
   createItemArgs[2] = jobParams.importNormals;
   createItemArgs[3] = jobParams.importUVs;
   createItemArgs[4] = jobParams.importVisibilityControllers;


   Abc::IObject shapeObj = fileShapeNode->getObject();
   const char* shapeFullName = shapeObj.getFullName().c_str();
   const char* xformFullName = NULL;

   CString newAppNodeName;
   if(fileXformNode){
      //if we will merge will the shape node with its parent transform, we use the name of the transform node 
      //(not the shape). This is done to avoid namespace conflicts.
      xformFullName = fileXformNode->getObject().getFullName().c_str();
      newAppNodeName = truncateName(fileXformNode->getObject().getName().c_str());
      fileShapeNode->setMerged(true);
   }
   else{
      newAppNodeName = truncateName(shapeObj.getName().c_str());
   }
   //EC_LOG_INFO( "Object name: " << newAppNodeName.GetAsciiString() );

   ESS_LOG_WARNING("xformName: "<<xformFullName<<" - shapeName: "<<shapeFullName);
   
   if(AbcG::ICamera::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ICamera");
      // let's create a camera
      CRef nodeRef;
      Camera camera;
      if(attachToExisting)
      {
	      ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not attach camera "<<shapeObj.getFullName());
            return false;
         }

         X3DObject x3dobject(nodeRef);
         if(!x3dobject.GetType().IsEqualNoCase(L"camera")){
            //x3dobject.ResetObject();
            ESS_LOG_ERROR("Can only attach "<<shapeObj.getFullName()<<" to a camera node.");
            return false;
         }
         camera = nodeRef;
      }
      else 
      {
         X3DObject parentX3DObject(appNode->nodeRef);
         parentX3DObject.AddCamera(L"Camera", newAppNodeName, camera);
         nodeRef = camera.GetRef();

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not create camera "<<shapeObj.getFullName());
            return false;
         }

         newAppNode = SceneNodePtr(new SceneNodeXSI(camera.GetRef()));

         nameMapAdd(shapeObj.getFullName().c_str(),camera.GetFullName());
      }

      // delete the interest
      CValueArray deleteArgs(1);
      deleteArgs[0] = camera.GetInterest().GetFullName();
      CValue setExprReturn;
      Application().ExecuteCommand(L"DeleteObj",deleteArgs,setExprReturn);

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // let's setup the xform op
      if(fileXformNode){
         alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
      }
      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // load camera
      alembic_create_item_Invoke(L"alembic_camera", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);
   }
   else if(AbcG::IPolyMesh::matches(shapeObj.getMetaData()) || AbcG::ISubD::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import IPolyMesh");

      X3DObject meshObj;
      CRef nodeRef;
      if(attachToExisting)
      {
	      ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not attach polymesh "<<shapeObj.getFullName());
         }

         X3DObject x3dobject(nodeRef);
         if(!x3dobject.GetType().IsEqualNoCase(L"PolyMsh")){
            x3dobject.ResetObject();
            ESS_LOG_ERROR("Can only attach "<<shapeObj.getFullName()<<" to a polymesh node.");
            return false;
         }

         meshObj = nodeRef;
      }
      else
      {
         X3DObject parentX3DObject(appNode->nodeRef);
  
         XSI::CStatus status;
         if(importBboxes){
            status = parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName, meshObj);
         }
         else{
            status = parentX3DObject.AddPrimitive(L"EmptyPolygonMesh", newAppNodeName, meshObj);
         }
         nodeRef = meshObj.GetRef();

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not create polymesh "<<shapeObj.getFullName());
         }

         newAppNode = SceneNodePtr(new SceneNodeXSI(meshObj.GetRef()));

         nameMapAdd(shapeObj.getFullName().c_str(),meshObj.GetFullName());
      }

      if(AbcG::ISubD::matches(shapeObj.getMetaData())){
         // make the geometry approx local
         CValue makeLocalReturn;
         CValueArray makeLocalArgs(2);
         makeLocalArgs[0] = meshObj.GetFullName()+L".geomapprox";
         makeLocalArgs[1] = siNodePropagation;
         Application().ExecuteCommand(L"MakeLocal",makeLocalArgs,makeLocalReturn);
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // create the topo op
      CRef returnOpRef;
      if(!importBboxes && !fileShapeNode->isMeshPointCache)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_polymesh_topo", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      bool bLoadGeoApprox = false;
   
      if(!importBboxes){
         if(AbcG::ISubD::matches(shapeObj.getMetaData())){
            bLoadGeoApprox = true;
         }
         else{
	         AbcG::IPolyMesh abcMesh = AbcG::IPolyMesh(shapeObj, Abc::kWrapExisting);
            bLoadGeoApprox = abcMesh.getSchema().getPropertyHeader( ".faceVaryingInterpolateBoundary" ) != NULL;
         }
      }
      if(bLoadGeoApprox){
		   alembic_create_item_Invoke(L"alembic_geomapprox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);
      }

	   // let's setup the xform op
      if(fileXformNode){
         alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
      }

      // let's setup the positions op
      if(importBboxes)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }
      else
      {
         //TODO: what is check for? what should be done in the case of SUBD
         // only add the point position operator if we don't have dynamic topology
        bool receivesExpression = fileShapeNode->isMeshTopoDynamic;
         
         if(!receivesExpression)
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_polymesh", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid()){
         alembic_create_item_Invoke(L"alembic_standin", importRootNode, returnOpRef, filename, shapeFullName, attachToExisting, createItemArgs);
      }
   }

   else if(AbcG::INuPatch::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import INuPatch");
      CRef nodeRef;
      X3DObject nurbsObj;
      if(attachToExisting)
      {
	      ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not attach Nurbs Patch "<<shapeObj.getFullName());
         }

         X3DObject x3dobject(nodeRef);
         if(!x3dobject.GetType().IsEqualNoCase(L"surfmsh"))
         {
            ESS_LOG_ERROR("Can only attach "<<shapeObj.getFullName()<<" to a surfmsh node.");
            return false;
         }
         nurbsObj = nodeRef;
      }

      if(!nurbsObj.IsValid())
      {
         std::stringstream s;
         s << "Can't create new Nurb surfaces, can only attach.  Unsupported Alembic type: " << shapeObj.getFullName().c_str();
         if( failOnUnsupported ) {
            ESS_LOG_ERROR( s.str().c_str() );
            return false;
         }
         ESS_LOG_WARNING( s.str().c_str() );
	   }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // let's setup the xform op
      if(fileXformNode){
         alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
      }

      alembic_create_item_Invoke(L"alembic_nurbs", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);
   }
   else if(AbcG::ICurves::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ICurves");
      // let's create a crvlist
      AbcG::ICurves curveIObject(shapeObj,Abc::kWrapExisting);
      AbcG::ICurvesSchema curveSchema = curveIObject.getSchema();
      AbcG::ICurvesSchema::Sample curveSample = curveSchema.getValue();

      // check for valid curve types...!
      if(curveSample.getType() != AbcG::kLinear &&
         curveSample.getType() != AbcG::kCubic)
      {
         std::stringstream s;
         s << "Can't create non-linear/non-cubic Curves.  Unsupported Alembic type: " << shapeObj.getFullName().c_str();
         if( failOnUnsupported ) {
            ESS_LOG_ERROR( s.str().c_str() );
            return false;
         }
         //ESS_LOG_WARNING( s.str().c_str() );
	   }

      // now let's check if we are looking at a curves node with color and radii

      bool useParticles = true;
      {
         Abc::IFloatArrayProperty propRadius;
         if( !getArbGeomParamPropertyAlembic( curveIObject, "radius", propRadius ) ) {
            useParticles = false;
         }
         Abc::IC4fArrayProperty propColor;
         if( !getArbGeomParamPropertyAlembic( curveIObject, "color", propColor ) ) {
            useParticles = false;
         } 
      }
      /*bool useParticles = curveSchema.getPropertyHeader( ".radius" ) != NULL || curveSchema.getPropertyHeader( ".color" ) != NULL;
      if(useParticles)
      {
         if( curveSchema.getPropertyHeader( ".radius" ) != NULL )
         {
            Abc::IFloatArrayProperty prop = Abc::IFloatArrayProperty( curveSchema, ".radius" );
            if(!prop.valid())
               useParticles = false;
            else if(prop.getNumSamples() == 0)
               useParticles = false;
         }
         else if( curveSchema.getPropertyHeader( ".color" ) != NULL )
         {
            Abc::IC4fArrayProperty prop = Abc::IC4fArrayProperty( curveSchema, ".color" );
            if(!prop.valid())
               useParticles = false;
            else if(prop.getNumSamples() == 0)
               useParticles = false;
         }
      }*/

      if (useParticles)
      {
         
         CRef nodeRef;        
         if(attachToExisting)
         {
 		      ESS_PROFILE_SCOPE("attachToExisting");
            nodeRef = appNode->nodeRef;

            if(!nodeRef.IsValid()){
               ESS_LOG_ERROR("Could not attach curve "<<shapeObj.getFullName());
            }

            X3DObject x3dobject(nodeRef);
            if(!x3dobject.GetType().IsEqualNoCase(L"pointcloud")){
               ESS_LOG_ERROR("Can only attach "<<shapeObj.getFullName()<<" to a pointcloud node.");
               return false;
            }
         }
         else
         {
            X3DObject parentX3DObject(appNode->nodeRef);
            X3DObject pointsObj;
            if(importBboxes){
               parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName, pointsObj);
            }
            else{
               parentX3DObject.AddPrimitive(L"PointCloud", newAppNodeName, pointsObj);
            }
            nodeRef = pointsObj.GetRef();
               
            if(!nodeRef.IsValid()){
               ESS_LOG_ERROR("Could not create curve "<<shapeObj.getFullName());
            }
            newAppNode = SceneNodePtr(new SceneNodeXSI(nodeRef));
            
            nameMapAdd(shapeObj.getFullName().c_str(), pointsObj.GetFullName());
         }

         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

         // load curves
         CRef returnOpRef;
         if(importBboxes)
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
         else
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_curves", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }

         // let's setup the xform op
         if(fileXformNode){
            alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
         }

         // load standin property
         if(importStandins && returnOpRef.IsValid()){
            alembic_create_item_Invoke(L"alembic_standin", importRootNode, returnOpRef, filename, shapeFullName, attachToExisting, createItemArgs);
         }
      }
      else
      {
         X3DObject curveObj;
         CRef nodeRef;
         if(attachToExisting)
         {
            ESS_PROFILE_SCOPE("attachToExisting");
            nodeRef = appNode->nodeRef;
            
            if(!nodeRef.IsValid()){
               ESS_LOG_ERROR("Could not attach curve "<<shapeObj.getFullName());
            }

            X3DObject x3dobject(nodeRef);
            if(!x3dobject.GetType().IsEqualNoCase(L"crvlist") && !x3dobject.GetType().IsEqualNoCase(L"hair")){
               ESS_LOG_ERROR("Can only attach "<<shapeObj.getFullName()<<" to crvlist or hair node.");
               return false;
            }
            curveObj = nodeRef;
         }
         else
         {
            X3DObject parentX3DObject(appNode->nodeRef);
            if(importBboxes){
               parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName, curveObj);
            }
            else{
               parentX3DObject.AddNurbsCurveList(CNurbsCurveDataArray(), siSINurbs, newAppNodeName, curveObj);
            }
            nodeRef = curveObj.GetRef();

            if(!nodeRef.IsValid()){
               ESS_LOG_ERROR("Could not create curve "<<shapeObj.getFullName());
            }

            newAppNode = SceneNodePtr(new SceneNodeXSI(nodeRef));

            nameMapAdd(shapeObj.getFullName().c_str(), curveObj.GetFullName());
         }

         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

         // load curve topo if it's not hair because that will already have desired topology if it exists
         if(!importBboxes && !curveObj.GetType().IsEqualNoCase(L"hair")){
            alembic_create_item_Invoke(L"alembic_crvlist_topo", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);
         }

         // load curve anim
         CRef returnOpRef;
         if(importBboxes){
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
         else{
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_crvlist", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }

         // allow stretching as there may have been dynamics applied to the hair
         if( curveObj.GetType().IsEqualNoCase(L"hair")){
            curveObj.GetActivePrimitive().PutParameterValue(L"AllowStretch", true);
         }

         // let's setup the xform op
         if(fileXformNode){
            alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
         }

         // load standin property
         if(importStandins && returnOpRef.IsValid()){
            alembic_create_item_Invoke(L"alembic_standin", importRootNode, returnOpRef, filename, shapeFullName, attachToExisting, createItemArgs);
         }
      }

   }
   else if(AbcG::IPoints::matches(shapeObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import IPoints");
      AbcG::IPoints pointsIObject(shapeObj,Abc::kWrapExisting);
      AbcG::IPointsSchema pointsSchema = pointsIObject.getSchema();
      AbcG::IPointsSchema::Sample pointsSample = pointsSchema.getValue();

      CRef nodeRef;
      if(attachToExisting)
      {
         ESS_PROFILE_SCOPE("attachToExisting");
         nodeRef = appNode->nodeRef;

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not attach points "<<shapeObj.getFullName());
         }

         X3DObject x3dobject(nodeRef);
         if(!x3dobject.GetType().IsEqualNoCase(L"pointcloud")){
            ESS_LOG_ERROR("Can only attach "<<shapeObj.getFullName()<<" to a  pointcloud node.");
            return false;
         }
      }
      else
      {
         X3DObject parentX3DObject(appNode->nodeRef);
         X3DObject pointsObj;
         if(importBboxes){
            parentX3DObject.AddGeometry(L"Cube", L"MeshSurface", newAppNodeName, pointsObj);
         }
         else{
            parentX3DObject.AddPrimitive(L"PointCloud", newAppNodeName, pointsObj);
         }
         nodeRef = pointsObj.GetRef();

         if(!nodeRef.IsValid()){
            ESS_LOG_ERROR("Could not create points "<<shapeObj.getFullName());
         }

         newAppNode = SceneNodePtr(new SceneNodeXSI(nodeRef));

         nameMapAdd(shapeObj.getFullName().c_str(), pointsObj.GetFullName());
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs);

      // let's setup the xform op
      if(fileXformNode){
         alembic_create_item_Invoke(L"alembic_xform", importRootNode, nodeRef, filename, xformFullName, attachToExisting, createItemArgs);
      }

      // apply the ice tree
      CRef returnOpRef;
      if(importBboxes) {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      } else {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_points", importRootNode, nodeRef, filename, shapeFullName, attachToExisting, createItemArgs, returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid()){
         alembic_create_item_Invoke(L"alembic_standin", importRootNode, returnOpRef, filename, shapeFullName, attachToExisting, createItemArgs);
      }
   }
   else { 
		std::stringstream s;
		s << "Unsupported Alembic type: " << shapeObj.getFullName().c_str();
		if( failOnUnsupported ) {
			ESS_LOG_ERROR( s.str().c_str() );
			return false;
		}
		ESS_LOG_WARNING( s.str().c_str() );
   }

   return true;
}



bool createNodes(SceneNodeXSI* const appNode, SceneNodeAlembic* const fileNode, const IJobStringParser& jobParams, SceneNodePtr& newAppNode)
{

   if( fileNode->type == SceneNode::ETRANSFORM ){//we have a transform with only one shape node child, so we can merge

      SceneNodeAlembic* shapeNode = NULL;
      for(SceneChildIterator it = fileNode->children.begin(); it != fileNode->children.end(); it++){
         if( hasExtractableTransform((*it)->type) ){
            shapeNode = (SceneNodeAlembic*)(*it).get();
            break;
         }
      }
      if(shapeNode){
         return createMergeableNode(appNode, fileNode, shapeNode, jobParams, newAppNode);
      }
      else{
         ESS_LOG_ERROR("Could not find shape node.");
         return false;
      }
   }
   else if( fileNode->type == SceneNode::ITRANSFORM ){// null nodes
      return createNode(appNode, fileNode, jobParams, newAppNode);
   }
   //this shape node has the same parent transform as one or more other shape nodes
   return createMergeableNode(appNode, NULL, fileNode, jobParams, newAppNode);
}


struct ImportStackElement
{
   SceneNodePtr sceneNode;
   CRef parentNode;

   ImportStackElement(SceneNodePtr node):sceneNode(node)
   {}
   ImportStackElement(SceneNodePtr node, CRef parent):sceneNode(node), parentNode(parent)
   {}

};

ESS_CALLBACK_START(alembic_import_Execute, CRef&)

	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");

   // inspect it
   CValueArray importJobArgs(1);
   CValue importJobResult;

   //CString filename = args[0];
   //bool importNormals = (bool)args[1];
   //bool importUVs = (bool)args[2];
   //bool importClusters = (bool)args[3];
   //bool importVisibility = (bool)args[4];
   //bool importStandins = (bool)args[5];
   //bool importBboxes = (bool)args[6];
   //bool attachToExisting = (bool)args[7];
   //bool failOnUnsupported = (bool)args[8];
   //CString identifierListStr = args[9].GetAsText();

   CString str("");
   str += "filename=";
   str += args[0].GetAsText();
   str += "normals=";
   str += args[1];
   str += "uvs=";
   str += args[2];
   str += "facesets=";
   str += args[3];
   str += "importVisibilityControllers=";
   str += args[4];
   str += "importStandinProperties=";
   str += args[5];
   str += "importBoundingBoxes=";
   str += args[6];
   str += "attachToExisting=";
   str += args[7];
   str += "failOnUnsupported=";
   str += args[8];
   str += "identifiers=";
   str += args[9].GetAsText();

   ESS_LOG_WARNING("The alembic_import command is deprecated. Please use alembic_import_jobs instead.");

   importJobArgs[0] = str;
   Application().ExecuteCommand(L"alembic_import_jobs", importJobArgs, importJobResult);

   if((bool)importJobResult){
      return CStatus::OK;
   }
   return CStatus::Abort;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_jobs_Execute, CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
	ESS_PROFILE_SCOPE("alembic_import_Execute");

   CRefArray selectedObjects = Application().GetSelection().GetArray();
   if(selectedObjects.GetCount() > 1)
   {
      Application().LogMessage(L"[ExocortexAlembic] Too many objects selected, you can select at most one attachment root.",siErrorMsg);
      return CStatus::InvalidArgument;
   }

   IJobStringParser jobParser;
   std::string jobString = args[0].GetAsText().GetAsciiString();

   if(jobString.empty()){

      // let's setup the property
      CustomProperty settings;
      settings = Application().GetActiveSceneRoot().AddProperty(L"alembic_import_settings");

      // inspect it
      CValueArray inspectArgs(5);
      CValue inspectResult;
      inspectArgs[0] = settings.GetFullName();
      inspectArgs[1] = L"";
      inspectArgs[2] = L"Import Settings";
      inspectArgs[3] = siModal;
      inspectArgs[4] = false;
      Application().ExecuteCommand(L"InspectObj",inspectArgs,inspectResult);
      
      // prepare for deletion
      inspectArgs.Resize(1);
      inspectArgs[0] = settings.GetFullName();
      if((bool)inspectResult) 
      {
         Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
         return CStatus::Abort;
      }

      // retrieve the options
      jobParser.importNormals = settings.GetParameterValue(L"normals");
      jobParser.importUVs = settings.GetParameterValue(L"uvs");
      jobParser.importFacesets = settings.GetParameterValue(L"facesets");
      jobParser.importVisibilityControllers = (bool)settings.GetParameterValue(L"visibility");
      if(hasStandinSupport())
      {
         LONG standinsValue = settings.GetParameterValue(L"standins");
         jobParser.importStandinProperties = standinsValue > 0;
         jobParser.importBoundingBoxes = standinsValue == 2;
      }
      else
      {
         jobParser.importStandinProperties = false;
         jobParser.importStandinProperties = false;
      }
      jobParser.attachToExisting = settings.GetParameterValue(L"attach");
	   jobParser.failOnUnsupported = settings.GetParameterValue(L"failOnUnsupported");

      Application().LogMessage(CString(L"[ExocortexAlembic] Using WriteJob:") + jobParser.buildJobString().c_str());

      Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
   }
   else{
      bool bParseSuccess = jobParser.parse(jobString);
      if(!bParseSuccess){
         ESS_LOG_ERROR("[alembic] Error parsing import job string.");
         return CStatus::Abort;
      }
      Application().LogMessage(CString(L"[ExocortexAlembic] Using WriteJob:") + jobString.c_str());
   }

   // take care of the filename
   if(jobParser.filename.empty())
   {
	  // let's see if we are in interactive mode
      if(Application().IsInteractive())
      {
         CComAPIHandler toolkit;
         toolkit.CreateInstance(L"XSI.UIToolkit");
         CComAPIHandler filebrowser(toolkit.GetProperty(L"FileBrowser"));
         filebrowser.PutProperty(L"InitialDirectory",Application().GetActiveProject().GetPath());
         filebrowser.PutProperty(L"Filter",L"Alembic Files(*.abc)|*.abc||");
         CValue returnVal;
         filebrowser.Call(L"ShowOpen",returnVal);
         jobParser.filename = filebrowser.GetProperty(L"FilePathName").GetAsText().GetAsciiString();
         if(jobParser.filename.empty()){
            return CStatus::Abort;
         }
      }
      else
      {
         Application().LogMessage(L"[ExocortexAlembic] No filename specified.",siErrorMsg);
         return CStatus::InvalidArgument;
      }
   }

   // let's try to read this
   Abc::IArchive* archive = NULL;
   try{
      archive = getArchiveFromID( jobParser.filename );
   }
   catch(Alembic::Util::Exception& e){
      std::string exc(e.what());
      ESS_LOG_ERROR("[alembic] Error reading file: "<<e.what());
      return CStatus::Fail;
   }
   catch(...){
      ESS_LOG_ERROR("[alembic] Error reading file.");
      return CStatus::Fail;
   }
   addRefArchive( jobParser.filename );
   AbcArchiveCache *pArchiveCache = getArchiveCache( jobParser.filename );

   CString filenameCStr(jobParser.filename.c_str());

   // also precap the jobParser.filename with the project token just in case
   CString projectPath = Application().GetActiveProject().GetPath();
   for(ULONG i=0;i<filenameCStr.Length();i++)
   {
      if(filenameCStr.GetAt(i) == '\\')
         filenameCStr = filenameCStr.GetSubString(0,i)+L"/"+filenameCStr.GetSubString(i+1,10000);
   }
   for(ULONG i=0;i<projectPath.Length();i++)
   {
      if(projectPath.GetAt(i) == '\\')
         projectPath = projectPath.GetSubString(0,i)+L"/"+projectPath.GetSubString(i+1,10000);
   }
   if(filenameCStr.GetSubString(0,projectPath.Length()) == projectPath)
   {
      filenameCStr = L"[project path]"+filenameCStr.GetSubString(projectPath.Length(),10000);
   }


   //TODO: no need to parse this argument twice
   // let's check the identifier list
   CString identifierListStr = args[9].GetAsText();
   std::map<std::string,bool> identifierMap;
   if(!identifierListStr.IsEmpty())
   {
      CStringArray identifiers = identifierListStr.Split(L",");
      for(LONG i=0;i<identifiers.GetCount();i++)
      {
         while(identifiers[i].GetAt(0) == ' ')
            identifiers[i] = identifiers[i].GetSubString(1,1000000);
         while(identifiers[i].GetAt(identifiers[i].Length()-1) == ' ')
            identifiers[i] = identifiers[i].GetSubString(0,identifiers[i].Length()-1);
         identifierMap.insert(std::pair<std::string,bool>(identifiers[i].GetAsciiString(),true));
      }
   }

   // create the timecontrol
   CustomProperty timeControl;
   if(jobParser.attachToExisting)
   {
      CRef timeRef;
      timeRef.Set(L"alembic_timecontrol");
      timeControl = timeRef;
   }
   CValueArray setExprArgs(2);
   CValue setExprReturn;
   if(!timeControl.IsValid())
   {
      timeControl = Application().GetActiveSceneRoot().AddProperty(L"alembic_timecontrol");

      // prepare values for the setexpr command
      setExprArgs[0] = timeControl.GetFullName()+L".current";
      setExprArgs[1] = L"T";
      Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
   }
   // now update the args to use the timecontrol instead
   setExprArgs[1] = timeControl.GetFullName()+L".current * "+timeControl.GetFullName()+L".factor + "+timeControl.GetFullName()+L".offset";

   //// store the time control in a value array
   //CValueArray createItemArgs(5);
   //createItemArgs[0] = timeControl.GetRef();
   //createItemArgs[1] = jobParser.importFacesets;
   //createItemArgs[2] = jobParser.importNormals;
   //createItemArgs[3] = jobParser.importUVs;
   //createItemArgs[4] = jobParser.importVisibilityControllers;

   AbcG::IObject root = archive->getTop();
 
   std::vector<std::string> nodesToImport;
   std::map<std::string, bool> map;

   AbcObjectCache *pRootObjectCache = &( pArchiveCache->find( "/" )->second );


   int nNumNodes = 0;
   SceneNodePtr fileRoot = buildAlembicSceneGraph(pArchiveCache, pRootObjectCache, nNumNodes);

   printSceneGraph(fileRoot, false);

   //return CStatus::Fail;

   //TODO need progress bar

   //ProgressBar prog;
   //prog = Application().GetUIToolkit().GetProgressBar();
   //prog.PutMinimum(0);
   //prog.PutMaximum(nNumNodes);//(identifierMap.size() == 0 ? (LONG)objects.size() : (LONG)identifierMap.size());
   //prog.PutValue(0);
   //prog.PutCancelEnabled(true);
   //prog.PutVisible(true);

   // clear the imported names!
   nameMapClear();
   CString transformCacheModelName;
   Model transformCacheModel;

   // clear all alembic user data
   alembic_UD::clearAll();


   CRef importRootNode = Application().GetActiveSceneRoot().GetRef();
   if(selectedObjects.GetCount() == 1)
   {
      importRootNode = selectedObjects[0];
      importRootNode = X3DObject( importRootNode ).GetParent3DObject().GetRef();
      //importRootNode = X3DObject( importRootNode ).GetRef();
      ESS_LOG_WARNING("Attachment root is "<<importRootNode.GetAsText().GetAsciiString());
   }

   //return CStatus::Fail;

   if(jobParser.attachToExisting)
   {
      SceneNodePtr appRoot = buildCommonSceneGraph(importRootNode);

      printSceneGraph(appRoot, false);

      bool bAttachSuccess = ImportSceneFile(fileRoot, appRoot, jobParser);

      if(!bAttachSuccess){
         return CStatus::Fail;
      }
   }
   else
   {
      //should build a full scene graph when start doing name checking
      SceneNodePtr appRoot(new SceneNodeXSI(importRootNode));

      bool bImportSuccess = ImportSceneFile(fileRoot, appRoot, jobParser);
      
      if(!bImportSuccess){
         return CStatus::Fail;
      }


    //  std::list<ImportStackElement> sceneStack;

    //  for(SceneChildIterator it = sceneRoot->children.begin(); it != sceneRoot->children.end(); it++){
    //     sceneStack.push_back(ImportStackElement(*it, importRootNode));
	   //}

    //  int intermittentUpdateInterval = std::max( (int)(nNumNodes / 100), (int)1 );
    //  int i = 0;
    //  while( !sceneStack.empty() )
    //  {
    //     ImportStackElement sElement = sceneStack.back();
    //     AbcObjectCache *pObjectCache = &( pArchiveCache->find(sElement.sceneNode->dccIdentifier)->second );
    //     Abc::IObject iObj = pObjectCache->obj;
    //     SceneNodePtr sceneNode = sElement.sceneNode;
    //     CRef parentNode(sElement.parentNode);

    //     sceneStack.pop_back();

    //     if( i % intermittentUpdateInterval == 0 ) {
    //        prog.PutCaption(L"Importing "+CString(iObj.getFullName().c_str())+L" ...");
    //     }
    //     i++;

    //    // bool bTransform = sceneNode->type == SceneNode::ITRANSFORM || sceneNode->type == SceneNode::ETRANSFORM; 
    //     //bool bMergeableTransform = sceneNode->type == SceneNode::ETRANSFORM;
    //     //bool bMergeableTransform = sceneNode->children.size() == 1 && hasExtractableTransform(sceneNode->children[0]->type);

    //     // ESS_LOG_WARNING("Processing "<<iObj.getFullName()<<" mergeable: "<<(bMergeableTransform?"true":"false")<<" transform: "<<(bTransform?"true":"false")  );

    //     bool bCreateNullNode = false;
    //     int nMergedGeomNodeIndex = -1;
    //     AbcObjectCache *pMergedGeomChildObjectCache = NULL;
    //     getMergeInfo( pArchiveCache, pObjectCache, bCreateNullNode, nMergedGeomNodeIndex, &pMergedGeomChildObjectCache );


    //     CRef newNodeRef;
    //     if(bCreateNullNode){
    //        createTransform( pObjectCache, importRootNode, parentNode, newNodeRef, filenameCStr, jobParser.attachToExisting, createItemArgs);
		  // }
		  // else{// multiple geometry nodes share the same parent. a shape node with the identity as it transform will be created.

    //        if(nMergedGeomNodeIndex != -1){ // create a shape node, and assign the parent xform as its transform
    //           pMergedGeomChildObjectCache = &( pArchiveCache->find(sceneNode->children.front()->dccIdentifier)->second );

				//   CStatus localStatus = createShape( pMergedGeomChildObjectCache, importRootNode, parentNode, newNodeRef, filenameCStr, 
    //              jobParser.attachToExisting, jobParser.importStandinProperties, jobParser.importBoundingBoxes, true, jobParser.failOnUnsupported, createItemArgs);
				//   if( ! localStatus.Succeeded() ) {
    //              delRefArchive( jobParser.filename );
				//	   return localStatus;
				//   }
    //        }
    //        else{
			 //     CStatus localStatus = createShape( pObjectCache, importRootNode, parentNode, newNodeRef, filenameCStr, 
    //              jobParser.attachToExisting, jobParser.importStandinProperties, jobParser.importBoundingBoxes, false, jobParser.failOnUnsupported, createItemArgs);
			 //     if( ! localStatus.Succeeded() ) {
    //              delRefArchive( jobParser.filename  );
				//      return localStatus;
			 //     }
    //        }
		  // }
    //     
    //     //newNodeRef will not be valid if we cannot attach children to it
    //     if(newNodeRef.IsValid()){

    //        //I assume that geometry nodes are always leaf nodes. Thus, if we merged a geometry node will its parent transform, we don't
    //        //need to push it to the stack.
    //        //A geometry node can't be combined with its transform node, the transform node has other tranform nodes as children. These
    //        //nodes must be pushed.

    //        

    //        //push the children as the last step, since we need to who the parent is first (we may have merged)
    //        for(SceneChildIterator it = sceneNode->children.begin(); it != sceneNode->children.end(); it++){
    //        
    //           AbcObjectCache *pChildObjectCache = &( pArchiveCache->find( (*it)->dccIdentifier )->second );
    //           AbcG::IObject childObj = pChildObjectCache->obj;
    //           if( NodeCategory::get(childObj) == NodeCategory::UNSUPPORTED ) continue;// skip over unsupported types
   
    //           if( pMergedGeomChildObjectCache == pChildObjectCache ) continue;

    //           sceneStack.push_back( ImportStackElement( *it, newNodeRef ) );
    //        }
    //        
    //     }
    //     else{
		  //    if( pObjectCache->childIdentifiers.size() > 0 ) {
			 //     EC_LOG_WARNING("Unsupported node: " << iObj.getFullName().c_str() << " has children that have not been imported." );
		  //    }
    //     }

    //     if(prog.IsCancelPressed()){
    //        break;
    //     }
    //     prog.Increment();
    //  }

   }



   //prog.PutVisible(false);

   delRefArchive( jobParser.filename );

   return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_import_settings_Define, CRef&)
	Context ctxt( in_ctxt );
	CustomProperty oCustomProperty;
	Parameter oParam;
	oCustomProperty = ctxt.GetSource();

   // get the current frame in an out
	oCustomProperty.AddParameter(L"normals",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"uvs",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"facesets",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"visibility",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   if(hasStandinSupport())
   {
      oCustomProperty.AddParameter(L"standins",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   }
   oCustomProperty.AddParameter(L"attach",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"failOnUnsupported",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_settings_DefineLayout, CRef&)
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();

   oLayout.AddGroup(L"Geometry");
   oLayout.AddItem(L"normals",L"Normals");
   oLayout.AddItem(L"uvs",L"UVs");
   oLayout.AddItem(L"facesets",L"Clusters");

   CValueArray items(4);
   items[0] = L"Just Import Value";
   items[1] = (LONG) 0l;
   items[2] = L"Connected Operators";
   items[3] = (LONG) 1l;
   oLayout.AddEnumControl(L"visibility",items,L"Visibility");

   if(hasStandinSupport())
   {
      items.Resize(6);
      items[0] = L"No standins";
      items[1] = (LONG) 0l;
      items[2] = L"Import data + standins";
      items[3] = (LONG) 1l;
      items[4] = L"Standins as bboxes";
      items[5] = (LONG) 2l;
      oLayout.AddEnumControl(L"standins",items,L"Standins");
   }
   oLayout.AddItem(L"attach",L"Attach to existing objects");
   oLayout.AddItem(L"failOnUnsupported",L"Fail Upon Unsupported Alembic Types");
   oLayout.EndGroup();

	return CStatus::OK;
ESS_CALLBACK_END
