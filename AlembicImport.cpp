// alembicPlugin
// Initial code generated by Softimage SDK Wizard
// Executed Fri Aug 19 09:14:49 UTC+0200 2011 by helge
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include "stdafx.h"
#include "arnoldHelpers.h" 

using namespace XSI; 
using namespace MATH; 

#include "AlembicLicensing.h"

#include "AlembicWriteJob.h"
#include "AlembicPoints.h"
#include "AlembicCurves.h"
#include "CommonProfiler.h"
#include "CommonMeshUtilities.h"
#include "CommonUtilities.h"

ESS_CALLBACK_START(alembic_import_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"filename");
   oArgs.Add(L"normals");
   oArgs.Add(L"uvs");
   oArgs.Add(L"clusters");
   oArgs.Add(L"visibility");
   oArgs.Add(L"standins");
   oArgs.Add(L"bboxes");
   oArgs.Add(L"attach");
   oArgs.Add(L"failOnUnsupported");
   oArgs.Add(L"identifiers");
	return CStatus::OK;
ESS_CALLBACK_END


bool hasMultipleSamples(Abc::IObject object)
{
   return getNumSamplesFromObject(object) > 1;
}

ESS_CALLBACK_START(alembic_create_item_Init,CRef&)
	Context ctxt( in_ctxt );
	Command oCmd;
	oCmd = ctxt.GetSource();
	oCmd.PutDescription(L"");
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs;
	oArgs = oCmd.GetArguments();
	oArgs.Add(L"type");
   oArgs.Add(L"target");
   oArgs.Add(L"file");
   oArgs.Add(L"identifier");
   oArgs.Add(L"reattach");
   oArgs.Add(L"timecontrolprop");
   oArgs.Add(L"facesets");
   oArgs.Add(L"normals");
   oArgs.Add(L"uvs");
   oArgs.Add(L"bindpose");
	return CStatus::OK;
ESS_CALLBACK_END


enum alembicItemType{
   alembicItemType_xform,
   alembicItemType_camera,
   alembicItemType_polymesh_topo,
   alembicItemType_bbox,
   alembicItemType_polymesh,
   alembicItemType_crvlist_topo,
   alembicItemType_crvlist,
   alembicItemType_curves,
   alembicItemType_points,
   alembicItemType_metadata,
   alembicItemType_timecontrol,
   alembicItemType_visibility,
   alembicItemType_geomapprox,
   alembicItemType_standin,
   alembicItemType_nurbs,
   alembicItemType_none
};

std::map<std::string,alembicItemType> gItemTypeMap;

CStatus alembic_create_item_Invoke
(
   const CString & type,
   const CRef& importRootNode, 
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting,
   const CValueArray & args,
   CValue & returnVal
)
{
	ESS_PROFILE_SCOPE("alembic_create_item_Invoke");

	// fill the map in case it is empty
   if(gItemTypeMap.size() == 0)
   {
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_xform",alembicItemType_xform));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_camera",alembicItemType_camera));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_polymesh_topo",alembicItemType_polymesh_topo));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_bbox",alembicItemType_bbox));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_polymesh",alembicItemType_polymesh));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_crvlist_topo",alembicItemType_crvlist_topo));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_crvlist",alembicItemType_crvlist));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_curves",alembicItemType_curves));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_points",alembicItemType_points));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_metadata",alembicItemType_metadata));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_timecontrol",alembicItemType_timecontrol));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_visibility",alembicItemType_visibility));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_geomapprox",alembicItemType_geomapprox));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_standin",alembicItemType_standin));
      gItemTypeMap.insert(std::pair<std::string,alembicItemType>("alembic_nurbs",alembicItemType_nurbs));
   }

   // query the item type from the map
   CString realType(type);
   realType.Lower();
   std::map<std::string,alembicItemType>::iterator it = gItemTypeMap.find(realType.GetAsciiString());
   alembicItemType itemType = alembicItemType_none;
   if(it != gItemTypeMap.end())
      itemType = it->second;

   // cast into the standard types
   X3DObject x3d(target);
   Primitive prim(target);

   // now let's find the real target for this
   CRef realTarget;
   { ESS_PROFILE_SCOPE("alembic_create_item_Invoke find_real_target");
   switch(itemType)
   {
      case alembicItemType_xform:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetKinematics().GetLocal().GetRef();
         else
         {
            KinematicState kine(target);
            if(kine.IsValid())
               realTarget = target;
            else
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      {
         if(x3d.IsValid())
         {
            Property visProp;
            if(itemType == alembicItemType_visibility)
               x3d.GetPropertyFromName(L"Visibility",visProp);
            else
            {
               x3d.GetPropertyFromName(L"GeomApprox",visProp);
            }
            realTarget = visProp.GetRef();
         }
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_camera:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetActivePrimitive().GetRef();
         else if(prim.IsValid())
            realTarget = prim.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(!Primitive(realTarget).GetType().IsEqualNoCase(L"camera"))
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_points:
      case alembicItemType_nurbs:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetActivePrimitive().GetRef();
         else if(prim.IsValid())
            realTarget = prim.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         // now check the type as well
         if(itemType == alembicItemType_polymesh_topo || itemType == alembicItemType_polymesh)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"polymsh"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_crvlist_topo || itemType == alembicItemType_crvlist)
         {
			CString type = Primitive(realTarget).GetType();
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"crvlist") && 
			   !Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud") &&
			   !Primitive(realTarget).GetType().IsEqualNoCase(L"hair"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_points || itemType == alembicItemType_curves)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"pointcloud"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         else if(itemType == alembicItemType_nurbs)
         {
            if(!Primitive(realTarget).GetType().IsEqualNoCase(L"surfmsh"))
            {
               Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      case alembicItemType_metadata:
      case alembicItemType_timecontrol:
      {
         if(x3d.IsValid())
            realTarget = x3d.GetRef();
         else
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         break;
      }
      case alembicItemType_standin:
      {
         CustomOperator alembicOp(target);
         ICETree alembicTree(target);
         if(!alembicOp.IsValid() && !alembicTree.IsValid())
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(!alembicOp.GetType().GetSubString(0,8).IsEqualNoCase(L"alembic_") && !alembicTree.GetName().GetSubString(0,4).IsEqualNoCase(L"abc_"))
         {
            Application().LogMessage(L"[ExocortexAlembic] Invalid target '"+target.GetAsText()+L"' for "+type+L".",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         if(alembicOp.IsValid())
            realTarget = alembicOp.GetRef();
         else
         {
            // loop for the first custom node
            CRefArray compounds = alembicTree.GetCompoundNodes();
            for(LONG j=0;j<compounds.GetCount();j++)
            {
               ICECompoundNode compound(compounds[j]);
               CRefArray nodes = compound.GetNodes();
               for(LONG k=0;k<nodes.GetCount();k++)
               {
                  CString nodeType = ICENode(nodes[k]).GetType();
                  if(nodeType.GetSubString(0,8).IsEqualNoCase(L"alembic_"))
                  {
                     realTarget = nodes[k];
                     break;
                  }
               }

               if(realTarget.IsValid())
                  break;
            }

            if(!realTarget.IsValid())
            {
               Application().LogMessage(L"[ExocortexAlembic] Could not find custom abc node on icetree '"+target.GetAsText()+L".",siErrorMsg);
               return CStatus::InvalidArgument;
            }
         }
         break;
      }
      default:
      {
         Application().LogMessage(L"[ExocortexAlembic] Unknown item type '"+type+L"'.",siErrorMsg);
         return CStatus::InvalidArgument;
      }
   }
   }

   // now validate the identifier if necessary
   Abc::IObject abcObject;
   bool isAnimated = false;
   { ESS_PROFILE_SCOPE("alembic_create_item_Invoke validate_the_identifier");
   switch(itemType)
   {
      case alembicItemType_xform:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_curves:
      case alembicItemType_metadata:
      case alembicItemType_points:
      case alembicItemType_geomapprox:
      case alembicItemType_nurbs:
      {
         abcObject = getObjectFromArchive(file,identifier);
         if(!abcObject.valid())
         {
            Application().LogMessage(L"[ExocortexAlembic] Identifier '"+identifier+L"' is not valid for given filename.",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         isAnimated = (itemType == alembicItemType_bbox) || (hasMultipleSamples(abcObject) && itemType != alembicItemType_geomapprox);
         break;
      }
      case alembicItemType_visibility:
      {
         abcObject = getObjectFromArchive(file,identifier);
         if(!abcObject.valid())
         {
            Application().LogMessage(L"[ExocortexAlembic] Identifier '"+identifier+L"' is not valid for given filename.",siErrorMsg);
            return CStatus::InvalidArgument;
         }
         AbcG::IVisibilityProperty visibilityProperty = 
            AbcG::GetVisibilityProperty(abcObject);
         if(!visibilityProperty.valid())
         {
            return CStatus::InvalidArgument;
         }
         isAnimated = visibilityProperty.getNumSamples() > 1;
         break;
      }
      case alembicItemType_standin:
      default:
         break;
   }
   }

    // check if we have a timecontrol in the args
    CustomProperty timeControlProp;
    CRef timeControlRef;
    if(args.GetCount() > 0)
       timeControlRef = args[0];
    timeControlProp = timeControlRef;
	CValue setExprReturn;
    CValueArray setExprArgs(2);  
	CString expressionString;
    if(timeControlProp.IsValid())
    {
       setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
	   expressionString = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
    }

    { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator");
   // now create an operator...?
   switch(itemType)
   {
      case alembicItemType_xform:
      case alembicItemType_visibility:
      case alembicItemType_geomapprox:
      case alembicItemType_camera:
      case alembicItemType_polymesh_topo:
      case alembicItemType_bbox:
      case alembicItemType_polymesh:
      case alembicItemType_crvlist_topo:
      case alembicItemType_crvlist:
      case alembicItemType_nurbs:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_xxx");
		// for visibility, let's see if we should create an operator
         if(itemType == alembicItemType_visibility)
         {
            bool importVis = args[4];
            if(!importVis)
            {
               // this means skip the creation of the operator
               AbcG::IVisibilityProperty visibilityProperty = 
                  AbcG::GetVisibilityProperty(abcObject);
               if(visibilityProperty.valid())
               {
                  int rawVisibilityValue = visibilityProperty.getValue ( size_t(0) );
                  AbcG::ObjectVisibility visibilityValue = AbcG::ObjectVisibility ( rawVisibilityValue );

                  Property prop(realTarget);
                  switch(visibilityValue)
                  {
                     case AbcG::kVisibilityVisible:
                     {
                        prop.PutParameterValue(L"viewvis",true);
                        prop.PutParameterValue(L"rendvis",true);
                        break;
                     }
                     case AbcG::kVisibilityHidden:
                     {
                        prop.PutParameterValue(L"viewvis",false);
                        prop.PutParameterValue(L"rendvis",false);
                        break;
                     }
                     default:
                     {
                        break;
                     }
                  }
                  break;
               }
            }
         }

         // for xform, disable softimage scaling
         if(itemType == alembicItemType_xform)
            KinematicState(realTarget).PutParameterValue(L"siscaling",false);

         CustomOperator op;
         if(attachToExisting)
         {
            CRef opRef;
            opRef.Set(realTarget.GetAsText()+L"."+realType);
            op = opRef;
         }
         if(!op.IsValid())
         {
			 {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator CreateObject");
		    op = Application().GetFactory().CreateObject(realType);
			 }

		/*	 		// Duplicate arc 4 times and translate in y
		args.Resize(19);
		args[0] = arc;					// source object
		args[1] = (LONG)4;				// number of copies
		args[9] = (LONG)siApplyRepeatXForm;	// Xform
		args[18] = (double)1;			// Ty
		app.ExecuteCommand( L"Duplicate", args, outArg );*/
			 
			 { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator AddPorts");
            op.AddOutputPort(realTarget);
            op.AddInputPort(realTarget);
			 }

            siConstructionMode consMode = siConstructionModeModeling;
            if(itemType != alembicItemType_crvlist_topo && itemType != alembicItemType_polymesh_topo)
               consMode = siConstructionModeAnimation;
			 { ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator Connect");
			
				op.Connect(consMode);
			 }
         }
 
         // setup the operator
         addRefArchive(file);
         op.PutParameterValue(L"path",file);
         op.PutParameterValue(L"identifier",identifier);

         // store the return value
         returnVal = op.GetRef();

         // if we are not a topo op, let's connect to the timecontrol
         bool receivesExpression = isAnimated;
         if(itemType == alembicItemType_crvlist_topo)
            receivesExpression = false;
         else if(itemType == alembicItemType_polymesh_topo)
         {
            // check if the compound has more than one sample on its facecounts
            Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
            Abc::IInt32ArrayProperty faceCountProp = Abc::IInt32ArrayProperty(abcCompound,".faceCounts");
            if(faceCountProp.valid())
               receivesExpression = !faceCountProp.isConstant();
            else
               receivesExpression = false;
         }

         if(receivesExpression)
         {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator receivesExpression");

            // check if we have a timecontrol in the args
             if(timeControlProp.IsValid())
            {
				 //setExprArgs[0] = op.GetFullName()+L".time";
				 op.GetParameter("time").AddExpression( expressionString );
				//Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
            }
         }

         // if we are a polygon mesh topo op, oh dear
         if(itemType == alembicItemType_polymesh_topo && args.GetCount() > 3)
         {
			 ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo");

            bool importClusters = args[1];
            bool importNormals = args[2];
            bool importUvs = args[3];

            AbcG::IPolyMesh abcMesh;
            AbcG::ISubD abcSubD;
            if(AbcG::IPolyMesh::matches(abcObject.getMetaData()))
               abcMesh = AbcG::IPolyMesh(abcObject,Abc::kWrapExisting);
            else
               abcSubD = AbcG::ISubD(abcObject,Abc::kWrapExisting);
            if(!abcMesh.valid() && !abcSubD.valid())
               return CStatus::OK;

            PolygonMesh meshGeo = Primitive(realTarget).GetGeometry();
            if(importClusters)
            {
        	  ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importClusters");
		       std::vector<std::string> faceSetNames;
               if(abcMesh.valid())
                  abcMesh.getSchema().getFaceSetNames(faceSetNames);
               else
                  abcSubD.getSchema().getFaceSetNames(faceSetNames);
               for(size_t j=0;j<faceSetNames.size();j++)
               {
                  if(attachToExisting)
                  {
                     if(meshGeo.GetClusters().GetItem(CString(faceSetNames[j].c_str())).IsValid())
                        continue;
                  }
                  AbcG::IFaceSetSchema faceSet;
                  if(abcMesh.valid())
                     faceSet = abcMesh.getSchema().getFaceSet(faceSetNames[j]).getSchema();
                  else
                     faceSet = abcSubD.getSchema().getFaceSet(faceSetNames[j]).getSchema();
                  AbcG::IFaceSetSchema::Sample faceSetSample = faceSet.getValue();
                  Abc::Int32ArraySamplePtr faces = faceSetSample.getFaces();
                  CLongArray elements((LONG)faces->size());
                  for(size_t k=0;k<faces->size();k++)
                     elements[(LONG)k] = (LONG)faces->get()[k];
                  Cluster cluster;
                  meshGeo.AddCluster(L"poly",CString(faceSetNames[j].c_str()),elements,cluster);
               }
            }
            if(importNormals && abcMesh.valid())
            {
              ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importNormals");
		       AbcG::IN3fGeomParam meshNormalsParam = abcMesh.getSchema().getNormalsParam();
               if(meshNormalsParam.valid())
               {
                  Abc::N3fArraySamplePtr meshNormals = meshNormalsParam.getExpandedValue(0).getVals();

                  CRef clusterPropRef;
                  if(attachToExisting)
                     clusterPropRef.Set(realTarget.GetAsText()+L".cls.User_Normal_Cluster.User_Normal_Property");
                  if(!clusterPropRef.IsValid())
                  {
                     // create user normals
                     CValue createUserNormalReturnVal;
                     CValueArray createUserNormalArgs(1);
                     createUserNormalArgs[0] = Primitive(realTarget).GetParent3DObject().GetFullName();
                     Application().ExecuteCommand(L"CreateUserNormals",createUserNormalArgs,createUserNormalReturnVal);
                  }
                  ClusterProperty userNormalProp;
                  CRefArray clusters = meshGeo.GetClusters();
                  for(LONG j=0;j<clusters.GetCount();j++)
                  {
                     Cluster cluster(clusters[j]);
                     if(!cluster.GetType().IsEqualNoCase(L"sample"))
                        continue;
                     CRefArray props(cluster.GetLocalProperties());
                     for(LONG k=0;k<props.GetCount();k++)
                     {
                        ClusterProperty prop(props[k]);
                        if(prop.GetType().IsEqualNoCase(L"normal"))
                        {
                           userNormalProp = props[k];
                           break;
                        }
                     }
                     if(userNormalProp.IsValid())
                        break;
                  }
                  if(userNormalProp.IsValid())
                  {
                     // we found it, and we need to attach the op
                     CustomOperator op;
                     if(attachToExisting)
                     {
                        CRef opRef;
                        opRef.Set(userNormalProp.GetFullName()+L".alembic_normals");
                        op = opRef;
                     }
                     if(!op.IsValid())
                     {
                        op = Application().GetFactory().CreateObject(L"alembic_normals");
                        op.AddOutputPort(userNormalProp.GetRef());
                        op.AddInputPort(userNormalProp.GetRef());
                        op.AddInputPort(realTarget);
                        op.Connect();
                     }
                     addRefArchive(file);
                     op.PutParameterValue(L"path",file);
                     op.PutParameterValue(L"identifier",identifier);
                     if(!timeControlProp.IsValid())
                     {
                        CRef timeControlRef;
                        if(args.GetCount() > 0)
                           timeControlRef = args[0];
                        timeControlProp = timeControlRef;
                     }
                     if(timeControlProp.IsValid())
                     {
                        CValue setExprReturn;
                        CValueArray setExprArgs(2);
                        setExprArgs[0] = op.GetFullName()+L".time";
                        setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
                        Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
                     }
                  }
               }
            }
            if(importUvs)
            {
                ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator polymesh_topo importUvs");
				AbcG::IV2fGeomParam meshUVsParam;
               if(abcMesh.valid())
                  meshUVsParam = abcMesh.getSchema().getUVsParam();
               else
                  meshUVsParam = abcSubD.getSchema().getUVsParam();
               if(meshUVsParam.valid())
               {
                  size_t numUVSamples = meshUVsParam.getNumSamples();
                  Abc::V2fArraySamplePtr meshUVs = meshUVsParam.getExpandedValue(0).getVals();
                  if(meshUVs->size() > 0)
                  {
                     // check if we have a uv set names prop
                     CStringArray uvSetNames;
                     if(abcMesh.valid())
                     {
                        if ( abcMesh.getSchema().getPropertyHeader( ".uvSetNames" ) != NULL )
                        {
                           Abc::IStringArrayProperty uvSetNamesProp = Abc::IStringArrayProperty( abcMesh.getSchema(), ".uvSetNames" );
                           Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                           for(size_t i=0;i<ptr->size();i++)
                              uvSetNames.Add(CString(ptr->get()[i].c_str()));
                        }
                     }
                     else
                     {
                        if ( abcSubD.getSchema().getPropertyHeader( ".uvSetNames" ) != NULL )
                        {
                           Abc::IStringArrayProperty uvSetNamesProp = Abc::IStringArrayProperty( abcSubD.getSchema(), ".uvSetNames" );
                           Abc::StringArraySamplePtr ptr = uvSetNamesProp.getValue(0);
                           for(size_t i=0;i<ptr->size();i++)
                              uvSetNames.Add(CString(ptr->get()[i].c_str()));
                        }
                     }
                     if(uvSetNames.GetCount() == 0)
                        uvSetNames.Add(L"Texture_Projection");

                     // for each uv set name
                     for(LONG uvI=0; uvI < uvSetNames.GetCount(); uvI++)
                     {
                        CRef clusterPropRef;
                        if(attachToExisting)
                           clusterPropRef.Set(realTarget.GetAsText()+L".cls.Texture_Coordinates_AUTO."+uvSetNames[uvI]);
                        if(!clusterPropRef.IsValid())
                        {
                           // create user normals
                           CValue createProjectionReturnVal;
                           CValueArray createProjectionArgs(5);
                           createProjectionArgs[0] = Primitive(realTarget).GetParent3DObject().GetFullName();
                           createProjectionArgs[1] = siTxtPureImplicit;
                           createProjectionArgs[2] = siTxtDefaultPlanarXY;
                           createProjectionArgs[3] = L"";
                           createProjectionArgs[4] = uvSetNames[uvI];
                           Application().ExecuteCommand(L"CreateProjection",createProjectionArgs,createProjectionReturnVal);
                        }
                        ClusterProperty uvProp;
                        CRefArray clusters = meshGeo.GetClusters();
                        for(LONG j=0;j<clusters.GetCount();j++)
                        {
                           Cluster cluster(clusters[j]);
                           if(!cluster.GetType().IsEqualNoCase(L"sample"))
                              continue;
                           CRefArray props(cluster.GetLocalProperties());
                           for(LONG k=0;k<props.GetCount();k++)
                           {
                              ClusterProperty prop(props[k]);
                              if(prop.GetType().IsEqualNoCase(L"uvspace") && prop.GetName().IsEqualNoCase(uvSetNames[uvI]))
                              {
                                 uvProp = props[k];
                                 break;
                              }
                           }
                           if(uvProp.IsValid())
                              break;
                        }
                        if(uvProp.IsValid())
                        {
                           // check if this alembic file has a uv options property
                           bool hasUvOptions = false;
                           if(abcMesh.valid())
                              hasUvOptions = abcMesh.getSchema().getPropertyHeader( ".uvOptions" ) != NULL;
                           else
                              hasUvOptions = abcSubD.getSchema().getPropertyHeader( ".uvOptions" ) != NULL;
                           if(hasUvOptions)
                           {
                              Abc::IFloatArrayProperty prop;
                              if(abcMesh.valid())
                                 prop = Abc::IFloatArrayProperty( abcMesh.getSchema(), ".uvOptions" );
                              else
                                 prop = Abc::IFloatArrayProperty( abcSubD.getSchema(), ".uvOptions" );

                              // if the prop stores any data
                              if(prop.getNumSamples() > 0)
                              {
                                 Abc::FloatArraySamplePtr ptr = prop.getValue(0);
                                 if(ptr->size() > 2 * uvI + 1)
                                 {
                                    bool uWrap = ptr->get()[uvI * 2 + 0] != 0.0f;
                                    bool vWrap = ptr->get()[uvI * 2 + 1] != 0.0f;

                                    CRefArray children = uvProp.GetNestedObjects();
                                    for(LONG i=0; i<children.GetCount(); i++)
                                    {
                                       ProjectItem child(children.GetItem(i));
                                       CString type = child.GetType();
                                       if(type == L"uvprojdef")
                                       {
                                          child.GetParameter(L"wrap_u").PutValue(uWrap);
                                          child.GetParameter(L"wrap_v").PutValue(vWrap);
                                          break;
                                       }
                                    }
                                 }
                              }
                           }

                           // we found it, and we need to attach the op
                           CustomOperator op;
                           if(attachToExisting)
                           {
                              CRef opRef;
                              opRef.Set(uvProp.GetFullName()+L".alembic_uvs");
                              op = opRef;
                           }
                           if(!op.IsValid())
                           {
                              op = Application().GetFactory().CreateObject(L"alembic_uvs");
                              op.AddOutputPort(uvProp.GetRef());
                              op.AddInputPort(uvProp.GetRef());
                              op.AddInputPort(realTarget);
                              op.Connect();
                           }
                           addRefArchive(file);
                           op.PutParameterValue(L"path",file);
                           op.PutParameterValue(L"identifier",identifier+CString(L":")+CString(uvI));
                           if(numUVSamples > 1)
                           {
                              CValue setExprReturn;
                              CValueArray setExprArgs(2);
                              setExprArgs[0] = op.GetFullName()+L".time";
                              setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
                              Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
                           }
                        }
                     }
                  }
               }
            }
         }

         break;
      }
      case alembicItemType_curves:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_curves");
		// let's setup the ICE tree to load it
         ICETree iceTree;
         CValueArray treeArgs(2);
         CValue treeReturnVal;
         if(attachToExisting)
         {
            CRef treeRef;
            treeRef.Set(realTarget.GetAsText()+L".ABC_Load_Curves");
            iceTree = treeRef;
         }
         if(!iceTree.IsValid())
         {
            treeArgs[0] = L"ABC Load Curves";
            treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
            Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
            iceTree = (CRef)treeReturnVal;
         }
         ICECompoundNode node = iceTree.GetCompoundNodes()[0];
         treeArgs[0] = node.GetFullName()+L".path_string";
         treeArgs[1] = file;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         treeArgs[0] = node.GetFullName()+L".identifier_string";
         treeArgs[1] = identifier;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         if(isAnimated)
         {
            // check if we have a timecontrol in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            CustomProperty timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               treeArgs[0] = node.GetFullName()+L".TimeControl";
               treeArgs[1] = timeControlProp.GetFullName();
               Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
            }
         }

         // store the return value
         returnVal = iceTree.GetRef();
         break;
      }
      case alembicItemType_points:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_points");
				// let's setup the ICE tree to load it
         ICETree iceTree;
         CValueArray treeArgs(2);
         CValue treeReturnVal;

         // we need to check if we have instances....
         AbcG::IPoints abcPoints(abcObject,Abc::kWrapExisting);
         if(!abcPoints.valid())
            return CStatus::OK;

		 Abc::IStringArrayProperty shapeInstanceNamesProp;
         if ( getArbGeomParamPropertyAlembic(abcPoints, "instancenames", shapeInstanceNamesProp) )
         {
            if(shapeInstanceNamesProp.getNumSamples() > 0)
            {
               Abc::StringArraySamplePtr shapeInstanceNamesPtr = shapeInstanceNamesProp.getValue(shapeInstanceNamesProp.getNumSamples()-1);
               if(shapeInstanceNamesPtr->size() > 0)
               {
                  if(attachToExisting)
                  {
                     CRef treeRef;
                     treeRef.Set(realTarget.GetAsText()+L".ABC_Instance_Shapes");
                     iceTree = treeRef;
                  }
                  if(!iceTree.IsValid())
                  {
                     treeArgs[0] = L"ABC Instance Shapes";
                     treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
                     Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
                     iceTree = (CRef)treeReturnVal;
                  }

                  for(size_t j=0;j<shapeInstanceNamesPtr->size();j++)
                  {
                     std::string instanceIdentifier = shapeInstanceNamesPtr->get()[j];
					 //replace spaces with underscores
					 for(int c=0; c<instanceIdentifier.size(); c++){
						 if(instanceIdentifier[c] == ' '){
                             instanceIdentifier[c] = '_';
						 }
					 }
                     CString fullName = getFullNameFromIdentifier(importRootNode,instanceIdentifier);
                     treeArgs[0] = iceTree.GetFullName()+L".ABC_Instance_Shapes.Reference"+CString((LONG)j);
                     treeArgs[1] = fullName;
                     Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);

                     // also check if we have this object in the scene
                     if(hasStandinSupport())
                     {
                        CRef ref;
                        ref.Set(fullName);
                        X3DObject x3d(ref);
                        if(x3d.IsValid())
                        {
                           // disable deferred loading on the instance sources
                           CRef standinPropRef;
                           standinPropRef.Set(fullName+L".arnold_standin");
                           Property prop(standinPropRef);
                           if(prop.IsValid())
                              prop.PutParameterValue(L"deferredLoading",false);

						   // enable hiding the instance masters
                           CRef visPropRef;
                           visPropRef.Set(fullName+L".visibility");
                           prop = Property(visPropRef);
                           if(prop.IsValid())
                              prop.PutParameterValue(L"hidemaster",true);
                        }
                     }
                  }
               }
            }
         }

         if(attachToExisting)
         {
            CRef treeRef;
            treeRef.Set(realTarget.GetAsText()+L".ABC_Load_Points");
            iceTree = treeRef;
         }
         if(!iceTree.IsValid())
         {
            treeArgs[0] = L"ABC Load Points";
            treeArgs[1] = Primitive(realTarget).GetParent3DObject().GetFullName();
            Application().ExecuteCommand(L"ApplyICEOp",treeArgs,treeReturnVal);
            iceTree = (CRef)treeReturnVal;
         }

         ICECompoundNode node = iceTree.GetCompoundNodes()[0];
         treeArgs[0] = node.GetFullName()+L".path_string";
         treeArgs[1] = file;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         treeArgs[0] = node.GetFullName()+L".identifier_string";
         treeArgs[1] = identifier;
         Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
         if(isAnimated)
         {
            // check if we have a timeControl in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            CustomProperty timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               treeArgs[0] = node.GetFullName()+L".TimeControl";
               treeArgs[1] = timeControlProp.GetFullName();
               Application().ExecuteCommand(L"SetValue",treeArgs,treeReturnVal);
            }
         }

         // store the return value
         returnVal = iceTree.GetRef();
         break;
      }
      case alembicItemType_metadata:
      {
			ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_metadata");
		Abc::ICompoundProperty abcCompound = getCompoundFromObject(abcObject);
         if ( abcCompound.getPropertyHeader( ".metadata" ) == NULL )
            break;

         Abc::IStringArrayProperty metaDataProp = Abc::IStringArrayProperty( abcCompound, ".metadata" );
         Abc::StringArraySamplePtr metaDataPtr = metaDataProp.getValue(0);
         if(metaDataPtr->size() != 20)
            break;

         // check if we already have the metadataprop
         CustomProperty xsiProp;
         CRefArray props = x3d.GetLocalProperties();
         for(LONG i=0;i<props.GetCount();i++)
         {
            CustomProperty prop(props[i]);
            if(!prop.IsValid())
               continue;
            if(!prop.GetType().IsEqualNoCase(L"alembic_metadata"))
               continue;
            xsiProp = prop;
            break;
         }
         if(!xsiProp.IsValid())
            xsiProp = x3d.AddProperty(L"alembic_metadata");

         // set all values
         size_t offset = 0;
         for(LONG i=0;i<10;i++)
         {
            xsiProp.PutParameterValue(L"name"+CString(i),CString(metaDataPtr->get()[offset++].c_str()));
            xsiProp.PutParameterValue(L"value"+CString(i),CString(metaDataPtr->get()[offset++].c_str()));
         }

         // store the return value
         returnVal = xsiProp.GetRef();
         break;
      }
      case alembicItemType_timecontrol:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_timecontrol");
		 CValueArray setExprArgs(2);
         CValue setExprReturn;
         CustomProperty timeControl = (CustomProperty) x3d.AddProperty(L"alembic_timecontrol");

         // prepare values for the setexpr command
         setExprArgs[0] = timeControl.GetFullName()+L".current";
         setExprArgs[1] = L"T";
         Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);

         // store the return value
         returnVal = timeControl.GetRef();
         break;
      }
      case alembicItemType_standin:
      {
         ESS_PROFILE_SCOPE("alembic_create_item_Invoke create_the_operator alembicItemType_standin");
		 // create an arnold property on the x3d if we don't have it yet!
         if(!hasStandinSupport())
         {
            Application().LogMessage(L"[ExocortexAlembic] There is no standin support. Please use a renderer supported standins.",siErrorMsg);
            return CStatus::InvalidArgument;
         }

         X3DObject sourceX3D = ProjectItem(realTarget).GetParent3DObject();
         CString projectItemName = ProjectItem(realTarget).GetFullName();
         CString sourceX3DFullName = sourceX3D.GetFullName();

         // let's see if we have the standin property already
         CustomProperty arnoldProp;
         CRef propRef;
         propRef.Set(sourceX3D.GetFullName()+L".arnold_standin");
         if(propRef.IsValid())
         {
            arnoldProp = CustomProperty(propRef);
         }
         else
         {
            arnoldProp = sourceX3D.AddProperty(L"arnold_standin",false);
         }

         // now check if the operator alrady exists
         CRef opRef;
         opRef.Set(arnoldProp.GetFullName()+L".alembic_standinop");
         if(!opRef.IsValid())
         {
            CustomOperator op = Application().GetFactory().CreateObject(L"alembic_standinop");
            op.AddOutputPort(arnoldProp.GetRef());
            op.AddInputPort(realTarget);
            op.Connect();

            // create the timecontrol expression
            // check if we have a timecontrol in the args
            CRef timeControlRef;
            if(args.GetCount() > 0)
               timeControlRef = args[0];
            Property timeControlProp = timeControlRef;
            if(timeControlProp.IsValid())
            {
               CValue setExprReturn;
               CValueArray setExprArgs(2);
               setExprArgs[0] = op.GetFullName()+L".time";
               setExprArgs[1] = timeControlProp.GetFullName()+L".current * "+timeControlProp.GetFullName()+L".factor + "+timeControlProp.GetFullName()+L".offset";
               Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
            }
         }

         break;
      }
      default:
         break;
   }
   }

   return CStatus::OK;
}


CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef& importRootNode,
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting,
   const CValueArray & args
)
{
	CValue returnVal;
	alembic_create_item_Invoke( type,importRootNode, target, file, identifier, attachToExisting, args, returnVal );
	return CStatus::OK;
}

CStatus alembic_create_item_Invoke
(
   const CString & type, 
   const CRef& importRootNode,
   const CRef & target,
   const CString & file,
   const CString & identifier,
   bool attachToExisting
)
{
	CValueArray args(0);
	alembic_create_item_Invoke( type, importRootNode, target, file, identifier, attachToExisting, args );
	return CStatus::OK;
}




ESS_CALLBACK_START(alembic_create_item_Execute, CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
   CString type = args[0];
   CRef importRootNode = args[1];
   CRef target = args[2];
   CString file = args[3];
   CString identifier = args[4];
   bool reattach = args[5];
   CValueArray additionalArgs;
   for(LONG i=6;i<args.GetCount();i++)
      additionalArgs.Add(args[i]);
   CValue returnVal;
   CStatus result = alembic_create_item_Invoke(type,importRootNode,target,file,identifier,reattach,additionalArgs,returnVal);
   ctxt.PutAttribute(L"ReturnValue",returnVal);
   return result;
ESS_CALLBACK_END


CStatus createTransform( Abc::IObject& iObj, CRef& importRootNode, CRef& parentNode, CRef& newNodeRef, CString& filename, bool attachToExisting, CValueArray& createItemArgs)
{
   X3DObject parentX3DObject(parentNode);
   CString name = truncateName(iObj.getName().c_str());

   if(AbcG::IXform::matches(iObj.getMetaData()))
   {

	   X3DObject x3dobject;
      //CRef nodeRef;
      if(attachToExisting)
      {
	      ESS_PROFILE_SCOPE("attachToExisting");
	      CRef modelRef;
         modelRef.Set(getFullNameFromIdentifier(importRootNode, iObj.getFullName(), false));
         x3dobject = modelRef;

         //if(!x3dobject.GetType().IsEqualNoCase(L"#model") && !x3dobject.GetType().IsEqualNoCase(L"null")){
         //   x3dobject.ResetObject();
         //}
         newNodeRef = x3dobject.GetRef();
      }

      if(!x3dobject.IsValid())
      {
		   Null null;
		   CRef nullRef;
		   nullRef.Set(getFullNameFromIdentifier(importRootNode, iObj.getFullName(), false));
		   null = nullRef;

         parentX3DObject.AddNull(name, null);
         nameMapAdd(iObj.getFullName().c_str(),null.GetFullName());
         newNodeRef = null.GetRef();
      }

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",importRootNode,newNodeRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // load xform
      alembic_create_item_Invoke(L"alembic_xform",importRootNode,newNodeRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
      
      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",importRootNode,newNodeRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
      
   }

   return CStatus( CStatus::OK );
}

CStatus createShape( Abc::IObject& iObj, CRef& importRootNode, CRef& parentNode, CRef& newNodeRef, CString& filename, bool attachToExisting, bool importStandins, bool importBboxes, bool wasMerged, bool failOnUnsupported, CValueArray& createItemArgs)
{
   X3DObject parentX3DObject(parentNode);
   Abc::IObject parent = iObj.getParent();
   CString name = truncateName(iObj.getName().c_str());

   //EC_LOG_INFO( "Object name: " << name.GetAsciiString() );

   // after dealing with transforms, let's deal with all shape types
   if(AbcG::ICamera::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ICamera");
      // let's create a camera
      Camera camera;
      if(attachToExisting)
      {
	   ESS_PROFILE_SCOPE("attachToExisting");
         CRef cameraRef;
         cameraRef.Set(getFullNameFromIdentifier(importRootNode,iObj.getFullName()));
         camera = cameraRef;
         if(!camera.GetType().IsEqualNoCase(L"camera"))
            camera.ResetObject();
      }
      if(!camera.IsValid())
      {
         parentX3DObject.AddCamera(L"Camera",name,camera);
         nameMapAdd(iObj.getFullName().c_str(),camera.GetFullName());
      }
	  newNodeRef = camera.GetRef();

      // delete the interest
      CValueArray deleteArgs(1);
      deleteArgs[0] = camera.GetInterest().GetFullName();
      CValue setExprReturn;
      Application().ExecuteCommand(L"DeleteObj",deleteArgs,setExprReturn);

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",importRootNode,camera.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // let's setup the xform op
      if(AbcG::IXform::matches(parent.getMetaData()) && wasMerged)
         alembic_create_item_Invoke(L"alembic_xform",importRootNode,camera.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);
      
      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",importRootNode,camera.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // load camera
      alembic_create_item_Invoke(L"alembic_camera",importRootNode,camera.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
   }
   else if(AbcG::IPolyMesh::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import IPolyMesh");

      X3DObject meshObj;
      if(attachToExisting)
      {
	   ESS_PROFILE_SCOPE("attachToExisting");
         CRef meshRef;
         meshRef.Set(getFullNameFromIdentifier(importRootNode,iObj.getFullName()));
         meshObj = meshRef;

         if(!meshObj.GetType().IsEqualNoCase(L"PolyMsh"))
            meshObj.ResetObject();
      }
      if(!meshObj.IsValid())
      {
         XSI::CStatus status;
         if(importBboxes)
            status = parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,meshObj);
         else
            status = parentX3DObject.AddPrimitive(L"EmptyPolygonMesh",name,meshObj);
         nameMapAdd(iObj.getFullName().c_str(),meshObj.GetFullName());
      }
      newNodeRef = meshObj.GetRef();

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // create the topo op
      CRef returnOpRef;
      if(!importBboxes && isAlembicMeshTopology(&iObj))
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_polymesh_topo",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

	  AbcG::IPolyMesh abcMesh = AbcG::IPolyMesh(iObj,Abc::kWrapExisting);
         
      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

     // load geometryapprox
	 if( ! importBboxes && abcMesh.getSchema().getPropertyHeader( ".faceVaryingInterpolateBoundary" ) != NULL )
		alembic_create_item_Invoke(L"alembic_geomapprox",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

	  // let's setup the xform op
      if(AbcG::IXform::matches(parent.getMetaData()) && wasMerged)
         alembic_create_item_Invoke(L"alembic_xform",importRootNode,meshObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);
      
      // let's setup the positions op
      if(importBboxes)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }
      else
      {
         // only add the point position operator if we don't have dynamic topology
         bool receivesExpression = isAlembicMeshTopoDynamic( & ( iObj ) );
         
         if(!receivesExpression)
         {
            AbcG::IPolyMesh abcMesh = AbcG::IPolyMesh(iObj,Abc::kWrapExisting);
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_polymesh",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid())
         alembic_create_item_Invoke(L"alembic_standin",importRootNode,returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
   }
   else if(AbcG::ISubD::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ISubD");
      X3DObject meshObj;
      if(attachToExisting)
      {
	   ESS_PROFILE_SCOPE("attachToExisting");
         CRef meshRef;
         meshRef.Set(getFullNameFromIdentifier(importRootNode,iObj.getFullName()));
         meshObj = meshRef;

         if(!meshObj.GetType().IsEqualNoCase(L"PolyMsh"))
            meshObj.ResetObject();
      }
      if(!meshObj.IsValid())
      {
         if(importBboxes)
            parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,meshObj);
         else
            parentX3DObject.AddPrimitive(L"EmptyPolygonMesh",name,meshObj);
         nameMapAdd(iObj.getFullName().c_str(),meshObj.GetFullName());
      }
	  newNodeRef = meshObj.GetRef();

      // make the geometry approx local
      CValue makeLocalReturn;
      CValueArray makeLocalArgs(2);
      makeLocalArgs[0] = meshObj.GetFullName()+L".geomapprox";
      makeLocalArgs[1] = siNodePropagation;
      Application().ExecuteCommand(L"MakeLocal",makeLocalArgs,makeLocalReturn);

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // create the topo op
      CRef returnOpRef;
      if(!importBboxes)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_polymesh_topo",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // load geometryapprox
      if(!importBboxes)
         alembic_create_item_Invoke(L"alembic_geomapprox",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // let's setup the xform op
      if(AbcG::IXform::matches(parent.getMetaData()) && wasMerged)
         alembic_create_item_Invoke(L"alembic_xform",importRootNode,meshObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);
      
      // let's setup the positions op
      if(importBboxes)
      {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }
      else
      {
         // only add the point position operator if we don't have dynamic topology
         AbcG::ISubD abcSubD = AbcG::ISubD(iObj,Abc::kWrapExisting);
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_polymesh",importRootNode,meshObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid())
         alembic_create_item_Invoke(L"alembic_standin",importRootNode,returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
   }
   else if(AbcG::INuPatch::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import INuPatch");
      X3DObject nurbsObj;
      if(attachToExisting)
      {
	   ESS_PROFILE_SCOPE("attachToExisting");
         CRef nurbsRef;
         nurbsRef.Set(getFullNameFromIdentifier(importRootNode,iObj.getFullName()));
         nurbsObj = nurbsRef;
         if(!nurbsObj.GetType().IsEqualNoCase(L"surfmsh"))
            nurbsObj.ResetObject();
         newNodeRef = nurbsObj.GetRef();
      }
      if(!nurbsObj.IsValid())
      {
		 std::stringstream s;
		s << "Can't create new Nurb surfaces, can only attach.  Unsupported Alembic type: " << iObj.getFullName().c_str();
		if( failOnUnsupported ) {
			ESS_LOG_ERROR( s.str().c_str() );
			return CStatus( CStatus::Fail );
		}
		ESS_LOG_WARNING( s.str().c_str() );
	
	  }
     // load metadata
     alembic_create_item_Invoke(L"alembic_metadata",importRootNode,nurbsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

     // let's setup the xform op
     if(AbcG::IXform::matches(parent.getMetaData()) && wasMerged)
        alembic_create_item_Invoke(L"alembic_xform",importRootNode,nurbsObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);
     
     alembic_create_item_Invoke(L"alembic_nurbs",importRootNode,nurbsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

     newNodeRef.Set(getFullNameFromIdentifier(importRootNode,iObj.getFullName()));
   }
   else if(AbcG::ICurves::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import ICurves");
      // let's create a crvlist
      AbcG::ICurves curveIObject(iObj,Abc::kWrapExisting);
      AbcG::ICurvesSchema curveSchema = curveIObject.getSchema();
      AbcG::ICurvesSchema::Sample curveSample = curveSchema.getValue();

      // check for valid curve types...!
      if(curveSample.getType() != AbcG::kLinear &&
         curveSample.getType() != AbcG::kCubic)
      {
        std::stringstream s;
		s << "Can't create non-linear/non-cubic Curves.  Unsupported Alembic type: " << iObj.getFullName().c_str();
		if( failOnUnsupported ) {
			ESS_LOG_ERROR( s.str().c_str() );
			return CStatus( CStatus::Fail );
		}
		ESS_LOG_WARNING( s.str().c_str() );
	  }

      // now let's check if we are looking at a curves node with color and radii

	 bool useParticles = true;
	 {
		 Abc::IFloatArrayProperty propRadius;
		 if( ! getArbGeomParamPropertyAlembic( curveIObject, "radius", propRadius ) ) {
			 useParticles = false;
		 }
		 Abc::IC4fArrayProperty propColor;
		 if( ! getArbGeomParamPropertyAlembic( curveIObject, "color", propColor ) ) {
			 useParticles = false;
		 } 
	 }
      /*bool useParticles = curveSchema.getPropertyHeader( ".radius" ) != NULL || curveSchema.getPropertyHeader( ".color" ) != NULL;
      if(useParticles)
      {
         if( curveSchema.getPropertyHeader( ".radius" ) != NULL )
         {
            Abc::IFloatArrayProperty prop = Abc::IFloatArrayProperty( curveSchema, ".radius" );
            if(!prop.valid())
               useParticles = false;
            else if(prop.getNumSamples() == 0)
               useParticles = false;
         }
         else if( curveSchema.getPropertyHeader( ".color" ) != NULL )
         {
            Abc::IC4fArrayProperty prop = Abc::IC4fArrayProperty( curveSchema, ".color" );
            if(!prop.valid())
               useParticles = false;
            else if(prop.getNumSamples() == 0)
               useParticles = false;
         }
      }*/

      if (useParticles)
      {
         X3DObject pointsObj;
         if(attachToExisting)
         {
 		   ESS_PROFILE_SCOPE("attachToExisting");
           CRef pointsRef;
            pointsRef.Set(getFullNameFromIdentifier(importRootNode,iObj.getFullName()));
            pointsObj = pointsRef;
            if(!pointsObj.GetType().IsEqualNoCase(L"pointcloud"))
               pointsObj.ResetObject();
         }
         if(!pointsObj.IsValid())
         {
            if(importBboxes)
               parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,pointsObj);
            else
               parentX3DObject.AddPrimitive(L"PointCloud",name,pointsObj);
            nameMapAdd(iObj.getFullName().c_str(),pointsObj.GetFullName());
         }
         newNodeRef = pointsObj.GetRef();
    
         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata",importRootNode,pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility",importRootNode,pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load curves
         CRef returnOpRef;
         if(importBboxes)
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_bbox",importRootNode,pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
         else
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_curves",importRootNode,pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }

         // let's setup the xform op
         if(AbcG::IXform::matches(parent.getMetaData()) && wasMerged)
            alembic_create_item_Invoke(L"alembic_xform",importRootNode,pointsObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);

         // load standin property
         if(importStandins && returnOpRef.IsValid())
            alembic_create_item_Invoke(L"alembic_standin",importRootNode,returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
      }
      else
      {
         X3DObject curveObj;
         if(attachToExisting)
         {
           ESS_PROFILE_SCOPE("attachToExisting");
            CRef curveRef;
            curveRef.Set(getFullNameFromIdentifier(importRootNode,iObj.getFullName()));
            curveObj = curveRef;
            if(!curveObj.GetType().IsEqualNoCase(L"crvlist") && !curveObj.GetType().IsEqualNoCase(L"hair"))
               curveObj.ResetObject();
         }
         if(!curveObj.IsValid())
         {
            if(importBboxes)
               parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,curveObj);
            else
               parentX3DObject.AddNurbsCurveList(CNurbsCurveDataArray(),siSINurbs,name,curveObj);
            nameMapAdd(iObj.getFullName().c_str(),curveObj.GetFullName());
         }
         newNodeRef = parentX3DObject.GetRef();

         // load metadata
         alembic_create_item_Invoke(L"alembic_metadata",importRootNode,curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load visibility
         alembic_create_item_Invoke(L"alembic_visibility",importRootNode,curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load curve topo if it's not hair because that will already have desired topology if it exists
         if(!importBboxes && !curveObj.GetType().IsEqualNoCase(L"hair"))
            alembic_create_item_Invoke(L"alembic_crvlist_topo",importRootNode,curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

         // load curve anim
         CRef returnOpRef;
         if(importBboxes)
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_bbox",importRootNode,curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }
         else
         {
            CValue returnedOpVal;
            alembic_create_item_Invoke(L"alembic_crvlist",importRootNode,curveObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
            returnOpRef = (CRef)returnedOpVal;
         }

         // allow stretching as there may have been dynamics applied to the hair
         if( curveObj.GetType().IsEqualNoCase(L"hair"))
         {
            curveObj.GetActivePrimitive().PutParameterValue(L"AllowStretch", true);
         }

         // let's setup the xform op
         if(AbcG::IXform::matches(parent.getMetaData()) && wasMerged)
            alembic_create_item_Invoke(L"alembic_xform",importRootNode,curveObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);

         // load standin property
         if(importStandins && returnOpRef.IsValid())
            alembic_create_item_Invoke(L"alembic_standin",importRootNode,returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
      }
   }
   else if(AbcG::IPoints::matches(iObj.getMetaData()))
   {
      //ESS_LOG_WARNING("Import IPoints");
      AbcG::IPoints pointsIObject(iObj,Abc::kWrapExisting);
      AbcG::IPointsSchema pointsSchema = pointsIObject.getSchema();
      AbcG::IPointsSchema::Sample pointsSample = pointsSchema.getValue();

      X3DObject pointsObj;
      if(attachToExisting)
      {
         ESS_PROFILE_SCOPE("attachToExisting");
         CRef pointsRef;
         pointsRef.Set(getFullNameFromIdentifier(importRootNode,iObj.getFullName()));
         pointsObj = pointsRef;
         if(!pointsObj.GetType().IsEqualNoCase(L"pointcloud"))
            pointsObj.ResetObject();
      }
      if(!pointsObj.IsValid())
      {
         if(importBboxes)
            parentX3DObject.AddGeometry(L"Cube",L"MeshSurface",name,pointsObj);
         else
            parentX3DObject.AddPrimitive(L"PointCloud",name,pointsObj);
         nameMapAdd(iObj.getFullName().c_str(),pointsObj.GetFullName());
      }
      newNodeRef = pointsObj.GetRef();

      // load metadata
      alembic_create_item_Invoke(L"alembic_metadata",importRootNode,pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // load visibility
      alembic_create_item_Invoke(L"alembic_visibility",importRootNode,pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);

      // let's setup the xform op
      if(AbcG::IXform::matches(parent.getMetaData()) && wasMerged)
         alembic_create_item_Invoke(L"alembic_xform",importRootNode,pointsObj.GetRef(),filename,parent.getFullName().c_str(),attachToExisting,createItemArgs);

      // apply the ice tree
      CRef returnOpRef;
      if(importBboxes) {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_bbox",importRootNode,pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      } else {
         CValue returnedOpVal;
         alembic_create_item_Invoke(L"alembic_points",importRootNode,pointsObj.GetRef(),filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs,returnedOpVal);
         returnOpRef = (CRef)returnedOpVal;
      }

      // load standin property
      if(importStandins && returnOpRef.IsValid())
         alembic_create_item_Invoke(L"alembic_standin",importRootNode,returnOpRef,filename,iObj.getFullName().c_str(),attachToExisting,createItemArgs);
   }
   else { 
		std::stringstream s;
		s << "Unsupported Alembic type: " << iObj.getFullName().c_str();
		if( failOnUnsupported ) {
			ESS_LOG_ERROR( s.str().c_str() );
			return CStatus( CStatus::Fail );
		}
		ESS_LOG_WARNING( s.str().c_str() );
   }
   return CStatus( CStatus::OK );
}



struct stackElement
{
   Abc::IObject iObj;
   CRef parentNode;

   stackElement(Abc::IObject iObj):iObj(iObj)
   {}
   stackElement(Abc::IObject iObj, CRef parent):iObj(iObj), parentNode(parent)
   {}

};


struct ImportStackElement
{
   Abc::IObject iObj;
   CRef parentNode;

   ImportStackElement(Abc::IObject iObj):iObj(iObj)
   {}
   ImportStackElement(Abc::IObject iObj, CRef parent):iObj(iObj), parentNode(parent)
   {}

};

ESS_CALLBACK_START(alembic_import_Execute, CRef&)
	Context ctxt( in_ctxt );
	CValueArray args = ctxt.GetAttribute(L"Arguments");
	ESS_PROFILE_SCOPE("alembic_import_Execute");

    CRefArray selectedObjects = Application().GetSelection().GetArray();
     if(selectedObjects.GetCount() > 1)
     {
        Application().LogMessage(L"[ExocortexAlembic] Too many objects selected, for re-basing root of import, you should only select a single object.",siErrorMsg);
        return CStatus::InvalidArgument;
     }

   // take care of the filename
   CString filename = (CString)args[0].GetAsText();
   if(filename.IsEmpty())
   {
	  // let's see if we are in interactive mode
      if(Application().IsInteractive())
      {
         CComAPIHandler toolkit;
         toolkit.CreateInstance(L"XSI.UIToolkit");
         CComAPIHandler filebrowser(toolkit.GetProperty(L"FileBrowser"));
         filebrowser.PutProperty(L"InitialDirectory",Application().GetActiveProject().GetPath());
         filebrowser.PutProperty(L"Filter",L"Alembic Files(*.abc)|*.abc||");
         CValue returnVal;
         filebrowser.Call(L"ShowOpen",returnVal);
         filename = filebrowser.GetProperty(L"FilePathName").GetAsText();
         if(filename.IsEmpty())
            return CStatus::Abort;
      }
      else
      {
         Application().LogMessage(L"[ExocortexAlembic] No filename specified.",siErrorMsg);
         return CStatus::InvalidArgument;
      }
   }

   // check if we have arguments
   if(args[1].GetAsText().IsEmpty())
   {
      // let's setup the property
      CustomProperty settings;
      settings = Application().GetActiveSceneRoot().AddProperty(L"alembic_import_settings");

      // inspect it
      CValueArray inspectArgs(5);
      CValue inspectResult;
      inspectArgs[0] = settings.GetFullName();
      inspectArgs[1] = L"";
      inspectArgs[2] = L"Import Settings";
      inspectArgs[3] = siModal;
      inspectArgs[4] = false;
      Application().ExecuteCommand(L"InspectObj",inspectArgs,inspectResult);
      
      // prepare for deletion
      inspectArgs.Resize(1);
      inspectArgs[0] = settings.GetFullName();
      if((bool)inspectResult)
      {
         Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
         return CStatus::Abort;
      }

      // retrieve the options
      args[1] = settings.GetParameterValue(L"normals");
      args[2] = settings.GetParameterValue(L"uvs");
      args[3] = settings.GetParameterValue(L"facesets");
      args[4] = settings.GetParameterValue(L"visibility");
      if(hasStandinSupport())
      {
         LONG standinsValue = settings.GetParameterValue(L"standins");
         args[5] = standinsValue > 0;
         args[6] = standinsValue == 2;
      }
      else
      {
         args[5] = false;
         args[6] = false;
      }
      args[7] = settings.GetParameterValue(L"attach");
	  args[8] = settings.GetParameterValue(L"failOnUnsupported");

      Application().ExecuteCommand(L"DeleteObj",inspectArgs,inspectResult);
   }

   // let's try to read this
   Abc::IArchive* archive = NULL;
   try{
      CString resolvedPath = CUtils::ResolveTokenString(filename,XSI::CTime(),false);
      archive = new Abc::IArchive( Alembic::AbcCoreHDF5::ReadArchive(), resolvedPath.GetAsciiString() );
   }
   catch(Alembic::Util::Exception& e){
      std::string exc(e.what());
      ESS_LOG_ERROR("[alembic] Error reading file: "<<e.what());
      return CStatus::Fail;
   }
   catch(...){
      ESS_LOG_ERROR("[alembic] Error reading file.");
      return CStatus::Fail;
   }

   // also precap the filename with the project token just in case
   CString projectPath = Application().GetActiveProject().GetPath();
   for(ULONG i=0;i<filename.Length();i++)
   {
      if(filename.GetAt(i) == '\\')
         filename = filename.GetSubString(0,i)+L"/"+filename.GetSubString(i+1,10000);
   }
   for(ULONG i=0;i<projectPath.Length();i++)
   {
      if(projectPath.GetAt(i) == '\\')
         projectPath = projectPath.GetSubString(0,i)+L"/"+projectPath.GetSubString(i+1,10000);
   }
   if(filename.GetSubString(0,projectPath.Length()) == projectPath)
   {
      filename = L"[project path]"+filename.GetSubString(projectPath.Length(),10000);
   }

   bool importNormals = (bool)args[1];
   bool importUVs = (bool)args[2];
   bool importClusters = (bool)args[3];
   bool importVisibility = (bool)args[4];
   bool importStandins = (bool)args[5];
   bool importBboxes = (bool)args[6];
   bool attachToExisting = (bool)args[7];
   bool failOnUnsupported = (bool)args[8];

   // let's check the identifier list
   CString identifierListStr = args[9].GetAsText();
   std::map<std::string,bool> identifierMap;
   if(!identifierListStr.IsEmpty())
   {
      CStringArray identifiers = identifierListStr.Split(L",");
      for(LONG i=0;i<identifiers.GetCount();i++)
      {
         while(identifiers[i].GetAt(0) == ' ')
            identifiers[i] = identifiers[i].GetSubString(1,1000000);
         while(identifiers[i].GetAt(identifiers[i].Length()-1) == ' ')
            identifiers[i] = identifiers[i].GetSubString(0,identifiers[i].Length()-1);
         identifierMap.insert(std::pair<std::string,bool>(identifiers[i].GetAsciiString(),true));
      }
   }

   // create the timecontrol
   CustomProperty timeControl;
   if(attachToExisting)
   {
      CRef timeRef;
      timeRef.Set(L"alembic_timecontrol");
      timeControl = timeRef;
   }
   CValueArray setExprArgs(2);
   CValue setExprReturn;
   if(!timeControl.IsValid())
   {
      timeControl = Application().GetActiveSceneRoot().AddProperty(L"alembic_timecontrol");

      // prepare values for the setexpr command
      setExprArgs[0] = timeControl.GetFullName()+L".current";
      setExprArgs[1] = L"T";
      Application().ExecuteCommand(L"SetExpr",setExprArgs,setExprReturn);
   }
   // now update the args to use the timecontrol instead
   setExprArgs[1] = timeControl.GetFullName()+L".current * "+timeControl.GetFullName()+L".factor + "+timeControl.GetFullName()+L".offset";

   // store the time control in a value array
   CValueArray createItemArgs(5);
   createItemArgs[0] = timeControl.GetRef();
   createItemArgs[1] = importClusters;
   createItemArgs[2] = importNormals;
   createItemArgs[3] = importUVs;
   createItemArgs[4] = importVisibility;

   AbcG::IObject root = archive->getTop();
 
   std::vector<std::string> nodesToImport;
   std::map<std::string, bool> map;
	int nNumNodes = prescanAlembicHierarchy(root, nodesToImport, map);


   ProgressBar prog;
   prog = Application().GetUIToolkit().GetProgressBar();
   prog.PutMinimum(0);
   prog.PutMaximum(nNumNodes);//(identifierMap.size() == 0 ? (LONG)objects.size() : (LONG)identifierMap.size());
   prog.PutValue(0);
   prog.PutCancelEnabled(true);
   prog.PutVisible(true);

   // clear the imported names!
   nameMapClear();
   CString transformCacheModelName;
   Model transformCacheModel;

   // clear all alembic user data
   alembic_UD::clearAll();


   CRef importRootNode = Application().GetActiveSceneRoot().GetRef();
   if(selectedObjects.GetCount() == 1)
   {
      importRootNode = selectedObjects[0];
      importRootNode = X3DObject( importRootNode ).GetParent3DObject().GetRef();
      //importRootNode = X3DObject( importRootNode ).GetRef();
   }

   std::list<ImportStackElement> sceneStack;
	for(size_t j=0; j<root.getNumChildren(); j++)
	{
      sceneStack.push_back(ImportStackElement(root.getChild(j), importRootNode));
	} 


   int intermittentUpdateInterval = std::max( (int)(nNumNodes / 100), (int)1 );
   int i = 0;
   while( !sceneStack.empty() )
   {
      ImportStackElement sElement = sceneStack.back();
      Abc::IObject iObj = sElement.iObj;
      CRef parentNode(sElement.parentNode);
      sceneStack.pop_back();

      if( i % intermittentUpdateInterval == 0 ) {
         prog.PutCaption(L"Importing "+CString(iObj.getFullName().c_str())+L" ...");
      }
      i++;

      //ESS_LOG_WARNING("Importing "<<iObj.getFullName().c_str()<<" ...");

      bool bCreateNullNode = false;
      int nMergedGeomNodeIndex = -1;
		AbcG::IObject mergedGeomChild;

      getMergeInfo(iObj, bCreateNullNode, nMergedGeomNodeIndex, mergedGeomChild);

      CRef newNodeRef;
		if(bCreateNullNode){

            createTransform( iObj, importRootNode, parentNode, newNodeRef, filename, attachToExisting, createItemArgs);
		}
		else{
			if(nMergedGeomNodeIndex != -1){//we are merging, so look at the child geometry node

				CStatus localStatus = createShape( mergedGeomChild, importRootNode,parentNode, newNodeRef, filename, attachToExisting, importStandins, importBboxes, true, failOnUnsupported, createItemArgs);
				if( ! localStatus.Succeeded() ) {
					return localStatus;
				}
			}
			else{ //geometry node(s) under a dummy node 

            //TODO: not sure if I handle the transforms correctly in this case
			//EC_LOG_ERROR( "[ExocortexAlembic] Merged geometry node index not -1" );
            //return CStatus::Abort;
				CStatus localStatus = createShape( iObj, importRootNode, parentNode, newNodeRef, filename, attachToExisting, importStandins, importBboxes, false, failOnUnsupported, createItemArgs);
				if( ! localStatus.Succeeded() ) {
					return localStatus;
				}
			}

		}
      
      //newNodeRef will not be valid if we cannot attach children to it
      if(newNodeRef.IsValid()){

         //push the children as the last step, since we need to who the parent is first (we may have merged)
	      for(size_t j=0; j<iObj.getNumChildren(); j++)
	      {
            AbcG::IObject childObj = iObj.getChild(j);
            if( NodeCategory::get(childObj) == NodeCategory::UNSUPPORTED ) continue;// skip over unsupported types

            //I assume that geometry nodes are always leaf nodes. Thus, if we merged a geometry node will its parent transform, we don't
            //need to push it to the stack.
            //A geometry node can't be combined with its transform node, the transform node has other tranform nodes as children. These
            //nodes must be pushed.
            if( nMergedGeomNodeIndex != j )
            {
               sceneStack.push_back( ImportStackElement(childObj, newNodeRef) );
            }
	      }
      }
      else{
		  if( iObj.getNumChildren() > 0 ) {
			  EC_LOG_WARNING("Unsupported node: " << iObj.getFullName().c_str() << " has children that have not been imported." );
		  }
      }

      if(prog.IsCancelPressed())
         break;
      prog.Increment();
   }

   prog.PutVisible(false);



   delete(archive);

   return CStatus::OK;
ESS_CALLBACK_END


ESS_CALLBACK_START(alembic_import_settings_Define, CRef&)
	Context ctxt( in_ctxt );
	CustomProperty oCustomProperty;
	Parameter oParam;
	oCustomProperty = ctxt.GetSource();

   // get the current frame in an out
	oCustomProperty.AddParameter(L"normals",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"uvs",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"facesets",CValue::siBool,siPersistable,L"",L"",1,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"visibility",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   if(hasStandinSupport())
   {
      oCustomProperty.AddParameter(L"standins",CValue::siInt4,siPersistable,L"",L"",0,0,10,0,10,oParam);
   }
   oCustomProperty.AddParameter(L"attach",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
   oCustomProperty.AddParameter(L"failOnUnsupported",CValue::siBool,siPersistable,L"",L"",0,0,1,0,1,oParam);
	return CStatus::OK;
ESS_CALLBACK_END

ESS_CALLBACK_START(alembic_import_settings_DefineLayout, CRef&)
	Context ctxt( in_ctxt );
	PPGLayout oLayout;
	PPGItem oItem;
	oLayout = ctxt.GetSource();
	oLayout.Clear();

   oLayout.AddGroup(L"Geometry");
   oLayout.AddItem(L"normals",L"Normals");
   oLayout.AddItem(L"uvs",L"UVs");
   oLayout.AddItem(L"facesets",L"Clusters");

   CValueArray items(4);
   items[0] = L"Just Import Value";
   items[1] = (LONG) 0l;
   items[2] = L"Connected Operators";
   items[3] = (LONG) 1l;
   oLayout.AddEnumControl(L"visibility",items,L"Visibility");

   if(hasStandinSupport())
   {
      items.Resize(6);
      items[0] = L"No standins";
      items[1] = (LONG) 0l;
      items[2] = L"Import data + standins";
      items[3] = (LONG) 1l;
      items[4] = L"Standins as bboxes";
      items[5] = (LONG) 2l;
      oLayout.AddEnumControl(L"standins",items,L"Standins");
   }
   oLayout.AddItem(L"attach",L"Attach to existing objects");
   oLayout.AddItem(L"failOnUnsupported",L"Fail Upon Unsupported Alembic Types");
   oLayout.EndGroup();

	return CStatus::OK;
ESS_CALLBACK_END
